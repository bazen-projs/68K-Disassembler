00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/12/2019 12:32:01 AM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : Motorola 68K Disassembler Final Capstone Project
00000000                             3  * Written by : Bazen Nega, Adam Deehring
00000000                             4  * Date       : 11 - 11 - 2019
00000000                             5  * 
00000000                             6  * Description: This code contains a method for you to use
00000000                             7  * with your Disassembler project IO, and a short demo of 
00000000                             8  * how to call this method in the body of the "START" code.
00000000                             9  * 
00000000                            10  * Hints and Tips:
00000000                            11  *   -Follow the code commenting convention here for file & method headers
00000000                            12  *   -Don't rename this file name (Main.X68)
00000000                            13  *   -Don't reorg the start address ($1000)
00000000                            14  *   -Don't rename or edit the IO method I've provided you with here
00000000                            15  *   -Don't rename the config.cfg file or change the file format: 
00000000                            16  *    <Long_StartAddress>\CR\LF
00000000                            17  *    <Long_EndAddress>\CR\LF<EOF>
00000000                            18  *---------------------------------------------------------------------------
00001000                            19      ORG    $1000    *Don't change this; see hints and tips above
00001000                            20  *---------------------------------------------------------------------------
00001000                            21  START:
00001000                            22      ***********************************************************
00001000                            23      * Code demo for printing strings to console & file is here
00001000                            24      * Pay close attention to:
00001000                            25      *   (1) the detailed comments, 
00001000                            26      *   (2) how to build a (Callee-Saved) method
00001000                            27      *   (3) how to call that method using JSR (return with RTS)
00001000                            28      ***********************************************************
00001000                            29      *LEA MSG1, A1        ; buffer of chars to write
00001000                            30      *JSR TrapTask13
00001000                            31      
00001000                            32      *LEA MSG2, A1        ; buffer of chars to write    
00001000                            33      *JSR TrapTask13
00001000                            34  
00001000                            35      *LEA ascii_val, A1
00001000                            36      *JSR AsciiToHex     ;  example of how to convert ascii to hex
00001000                            37  
00001000  4EB9 00002A40             38          JSR StoreAddressesFromConfig
00001006                            39           
00001006  4BF9 00002A9F             40          LEA String_Buffer_Block,A5
0000100C                            41          
0000100C  2879 00002AEC             42          MOVEA.L Start_Address,A4   * move start address to A4 (which will parse through the "testing region" in the final code)
00001012  B9FC FFFFFFFF             43          CMPA.L #$FFFFFFFF,A4
00001018  6700 1322                 44          BEQ end_Program
0000101C                            45          
0000101C                            46  *********************************************************************************
0000101C                            47  * Method Name: start_Disassembly
0000101C                            48  * Description: Iterates through the memory region that will be disassembled, and checks
0000101C                            49  *              checks for the matching of various supported instructions with the opcode
0000101C                            50  *              being read (branches to specialized disassembling function for opcode if match found,
0000101C                            51  *              otherwise continue checking for a match with the next supported instruction)
0000101C                            52  *
0000101C                            53  * Calling Convention: Neither
0000101C                            54  *
0000101C                            55  * Preconditions & Method Input:
0000101C                            56  *   A start address has been provided in A4, and an end address has been provided in the memory location of
0000101C                            57  *   a variable named "End_Address" 
0000101C                            58  *
0000101C                            59  * Postconditions & Output:
0000101C                            60  *   An opcode instruction specialized decoding function is branched to, or we branch to the end of the program
0000101C                            61  *
0000101C                            62  *  D7 holds a copy of the current instruction pointed to by A4
0000101C                            63  *  A4 points to the instruction currently being decoded
0000101C                            64  *  A5 points at the head of the string buffer block holding the string to be printed out by "TrapTask13"
0000101C                            65  *  D5 holds a number to be shifted by for a shift operation if the shift value needed exceeds 8
0000101C                            66  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
0000101C                            67  ********************************************************************************
0000101C                            68  start_Disassembly:
0000101C  B9F9 00002AF0             69          CMPA.L End_Address,A4
00001022  6E00 1318                 70          BGT end_Program
00001026  7002                      71          MOVE.L #2,D0
00001028  4286                      72          CLR.L D6
0000102A  4284                      73          CLR.L D4
0000102C  4285                      74          CLR.L D5
0000102E  4282                      75          CLR.L D2
00001030  4281                      76          CLR.L D1
00001032  207C 00000000             77          MOVE.L #$0000,A0
00001038  227C 00000000             78          MOVE.L #$0000,A1
0000103E  247C 00000000             79          MOVE.L #$0000,A2
00001044  267C 00000000             80          MOVE.L #$0000,A3
0000104A  2A7C 00000000             81          MOVE.L #$0000,A5
00001050  2C4C                      82          MOVE.L A4,A6
00001052  204C                      83          MOVE.L A4,A0
00001054  4EB9 00002992             84          JSR Clear_String_Buffer
0000105A  4BF9 00002A9F             85          LEA String_Buffer_Block,A5
00001060                            86  **********Lines added to get print the addresses before a disassembled instruction - 5 lines of code - Start****************
00001060  220C                      87          MOVE.L A4,D1
00001062  363C 001C                 88          MOVE #28,D3
00001066  4EB9 000029BC             89          JSR Add_Hex_String_To_Buffer
0000106C  4EB9 0000290A             90          JSR Add_Space
00001072  4281                      91          CLR.L D1
00001074                            92  **********Lines added to get print the addresses before a disassembled instruction - 5 lines of code - End******************
00001074                            93          *LEA my_Test_Value, A1 * loads the test value into A1
00001074                            94          *MOVEA A1, A0          * saves the address of A1 into A0
00001074                            95          *JSR AsciiToHex        * call the AscciToHex function to convert the test value from ascii to hex
00001074  3E14                      96          MOVE.W (A4),D7
00001076  2607                      97          MOVE.L D7, D3         * moves the converted hex value to D3
00001078                            98          *ANDI.L #$FFFF0000,D3 * checks for a NOP operation
00001078                            99          *MOVE #16,D5
00001078                           100          *LSR.L D5,D3
00001078  0C43 4E71                101          CMPI #$4E71,D3
0000107C  6700 12C6                102          BEQ NOP_Operation
00001080  4EB9 000028D2            103          JSR Place_D7_in_D3 * re-initializes the value of D3 to the Hex instruction to be deassembled
00001086                           104          *ANDI.L #$FFFF,D3 * checks for an RTS operation
00001086                           105          *MOVE #16,D5
00001086                           106          *LSR.L D5,D3
00001086  0C43 4E75                107          CMPI #$4E75,D3
0000108A  6700 12D0                108          BEQ RTS_Operation
0000108E  4EB9 000028D2            109          JSR Place_D7_in_D3
00001094  0283 0000FFC0            110          ANDI.L #JSR_Mask,D3
0000109A  EC8B                     111          LSR.L #6,D3
0000109C  0C43 013A                112          CMPI.W #314,D3
000010A0  6700 0B88                113          BEQ Start_JSR_Disassembly
000010A4  4EB9 000028D2            114          JSR Place_D7_in_D3
000010AA  0283 0000FF00            115          ANDI.L #NEG_BRA_Mask,D3
000010B0  E08B                     116          LSR.L #8,D3
000010B2  0C43 0044                117          CMPI.W #68,D3
000010B6  6700 0AB0                118          BEQ Start_NEG_Disassembly
000010BA  0C43 000C                119          CMPI.W #12,D3
000010BE  6700 074C                120          BEQ Start_CMPI_Disassembly
000010C2  0C43 0000                121          CMPI #0,D3
000010C6  6700 0366                122          BEQ Start_ORI_Disassembly
000010CA  4EB9 000028D2            123          JSR Place_D7_in_D3
000010D0  0283 0000F1C0            124          ANDI.L #LEA_MULS_Mask,D3
000010D6  EC8B                     125          LSR.L #6,D3
000010D8  0C43 0107                126          CMPI.W #263,D3
000010DC  6700 0B0E                127          BEQ Start_LEA_Disassembly
000010E0  0C43 0307                128          CMPI #775,D3
000010E4  6700 00E6                129          BEQ Start_MULTS_Disassembly
000010E8  0C43 0207                130          CMPI #519, D3
000010EC  6700 00EE                131          BEQ Start_DIVS_Disassembly
000010F0  4EB9 000028D2            132          JSR Place_D7_in_D3
000010F6  0283 0000F000            133          ANDI.L #Bcc_CMPI_Mask,D3
000010FC  3A3C 000C                134          MOVE #12,D5
00001100  EAAB                     135          LSR.L D5,D3
00001102  0C43 0006                136          CMPI.W #6,D3
00001106  6700 0934                137          BEQ Start_Bcc_Disassembly
0000110A  0C43 000E                138          CMPI.W #14,D3
0000110E  6700 0488                139          BEQ Start_Shifting_Disassembly
00001112  0C43 0008                140          CMPI.W #8,D3
00001116  6700 03C2                141          BEQ Start_OR_Disassembly
0000111A  0C43 000D                142          CMPI.W #13,D3
0000111E  6700 01DE                143          BEQ Start_Add_Disassembly
00001122  0C43 0009                144          CMPI.W #9,D3
00001126  6700 01C4                145          BEQ Start_Sub_Disassembly
0000112A  4EB9 000028D2            146          JSR Place_D7_in_D3
00001130  0283 0000F100            147          ANDI.L #SubQ_Mask,D3
00001136  E08B                     148          LSR.L #8,D3
00001138  0C43 0051                149          CMPI.W #81,D3
0000113C  6700 00F0                150          BEQ Start_SubQ_Disassembly
00001140  4EB9 000028D2            151          JSR Place_D7_in_D3
00001146  0283 0000FF80            152          ANDI.L #MoveM_Op_Code_Mask,D3
0000114C  3A3C 0007                153          MOVE #7,D5
00001150  EAAB                     154          LSR.L D5,D3
00001152  0C43 0091                155          CMPI.W #145,D3
00001156  6700 0BE0                156          BEQ Start_MoveM_toM_Disassembly
0000115A  0C43 0099                157          CMPI.W #153,D3
0000115E  6700 0BD8                158          BEQ Start_MoveM_toM_Disassembly
00001162  4EB9 000028D2            159          JSR Place_D7_in_D3
00001168  0283 0000F1C0            160          ANDI.L #Bit_Test_and_Clear_Mask,D3 * start testing for BCLR instruction (Test a Bit and Clear)
0000116E  0C43 0180                161          CMPI.W #384,D3
00001172  6700 0ADE                162          BEQ Start_Test_Bit_Clear_Disassembly1
00001176  4EB9 000028D2            163          JSR Place_D7_in_D3
0000117C  0283 0000FFC0            164          ANDI.L #Bit_Test_and_Clear_Mask2,D3
00001182  EC8B                     165          LSR.L #6,D3
00001184  0C43 0022                166          CMPI.W #34,D3
00001188  6700 0AF0                167          BEQ Start_Test_Bit_Clear_Disassembly2
0000118C  4EB9 000028D2            168          JSR Place_D7_in_D3
00001192  0283 0000F000            169          ANDI.L #Bcc_CMPI_Mask,D3
00001198  3A3C 000C                170          MOVE #12,D5
0000119C  EAAB                     171          LSR.L D5,D3
0000119E  0C03 000B                172          CMPI.B #11,D3
000011A2  6700 075C                173          BEQ Start_CMP_Disassembly
000011A6  4EB9 000028D2            174          JSR Place_D7_in_D3
000011AC  0283 0000F000            175          ANDI.L #$F000, D3 * Performs a an AND operation on the converted value with a bitmask and stores the result in D3 (isolates the first four bits)
000011B2  3A3C 000C                176          MOVE #12,D5           * sets the shift count for how many bits right the first four bits will be shifted to be at the least significant portion of the hex value (32 bits in total, we're starting to move at the 28th bit, hence, shift 28)
000011B6  EAAB                     177          LSR.L D5,D3           * shift the bit values in D3 by the value in D5 (28)
000011B8  0C03 0004                178          CMPI.B #4,D3
000011BC  6D00 1024                179          BLT Start_Move_Disassembly * statement checks if D3 is less than 4 to confirm "MOVE" operation
000011C0  4EB9 00002A06            180          JSR Error_Subroutine
000011C6  D8C0                     181          ADDA D0,A4
000011C8  6000 FE52                182          BRA start_Disassembly
000011CC                           183  
000011CC                           184  *********************************************************************************
000011CC                           185  * Method Name: Start_MULS_DIVS_Disassembly
000011CC                           186  * Description: Begins processing of the decoding of a MULS or DIVS instruction. It will load
000011CC                           187  *              appropriate ascii chars into the string buffer, call the "DestAddressingModeDetermine" function to determine effective addresses, 
000011CC                           188  *              and print the appropriate string represented assembly language MULS/DIVS instruction.
000011CC                           189  *
000011CC                           190  * Calling Convention: Callee-Saved
000011CC                           191  *
000011CC                           192  * Preconditions & Method Input:
000011CC                           193  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
000011CC                           194  *
000011CC                           195  * Postconditions & Output:
000011CC                           196  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
000011CC                           197  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
000011CC                           198  *   necessary amount given current instruction format.
000011CC                           199  *
000011CC                           200  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "MULS" or "DIVS")
000011CC                           201  *  D7 holds the current instruction opcode word
000011CC                           202  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
000011CC                           203  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
000011CC                           204  *  the function to know which addressing modes to forbid for this instruction.
000011CC                           205  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
000011CC                           206  *  A3 stores a flag telling the effective address function what size the operation is (this only has significance if the effective address is determined to be immediate)
000011CC                           207  *  D0 stores the amount by which A4 will be incremented after the completion of this function
000011CC                           208  ********************************************************************************
000011CC                           209  Start_MULS_DIVS_Disassembly        
000011CC                           210  Start_MULTS_Disassembly
000011CC  45F9 00002B79            211          LEA MULS_op,A2
000011D2  4EB9 00002972            212          JSR Start_String_Appending
000011D8  6000 000E                213          BRA After_MULTS_Decision
000011DC                           214  Start_DIVS_Disassembly
000011DC  45F9 00002B7E            215          LEA DIVS_op,A2
000011E2  4EB9 00002972            216          JSR Start_String_Appending
000011E8                           217  After_MULTS_Decision
000011E8  4EB9 000028D2            218          JSR Place_D7_in_D3
000011EE  45F9 00002B87            219          LEA Word_Size,A2
000011F4  4EB9 00002972            220          JSR Start_String_Appending
000011FA  367C 0002                221          MOVE #2,A3
000011FE  4242                     222          CLR D2
00001200  383C 0054                223          MOVE #84,D4
00001204  4EB9 00002374            224          JSR DestAddressingModeDetermine
0000120A  4EB9 000028FC            225          JSR Add_Comma
00001210  4244                     226          CLR D4
00001212  343C 0001                227          MOVE #1,D2
00001216  4EB9 00002298            228          JSR R_Destination
0000121C  D8C0                     229          ADDA D0,A4
0000121E  4EB9 00002694            230          JSR TrapTask13
00001224  4EB9 00002992            231          JSR Clear_String_Buffer
0000122A  6000 FDF0                232          BRA start_Disassembly
0000122E                           233          
0000122E                           234          
0000122E                           235  *********************************************************************************
0000122E                           236  * Method Name: Start_SubQ_Disassembly
0000122E                           237  * Description: Begins processing of the decoding of a SUBQ instruction. It will load
0000122E                           238  *              appropriate ascii chars into the string buffer, call the "DestAddressingModeDetermine" function to determine effective addresses, 
0000122E                           239  *              and print the appropriate string represented assembly language SUBQ instruction.
0000122E                           240  *
0000122E                           241  * Calling Convention: Callee-Saved
0000122E                           242  *
0000122E                           243  * Preconditions & Method Input:
0000122E                           244  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
0000122E                           245  *
0000122E                           246  * Postconditions & Output:
0000122E                           247  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
0000122E                           248  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
0000122E                           249  *   necessary amount given current instruction format.
0000122E                           250  *
0000122E                           251  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "SUBQ")
0000122E                           252  *  A4 points to the current instruction opcode
0000122E                           253  *  D7 holds the current instruction opcode word
0000122E                           254  *  D5 holds a number to be shifted by for a shift operation if the shift value needed exceeds 8
0000122E                           255  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
0000122E                           256  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
0000122E                           257  *  the function to know which addressing modes to forbid for this instruction.
0000122E                           258  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
0000122E                           259  *  D0 stores the amount by which A4 will be incremented after the completion of this function
0000122E                           260  *  D6 temporarily stores values that D3 would store while D3 is occupied bit masking for other tasks at the moment
0000122E                           261  Start_SubQ_Disassembly
0000122E  45F9 00002B74            262          LEA SubQ_op,A2
00001234  4EB9 00002972            263          JSR Start_String_Appending
0000123A  4EB9 000028D2            264          JSR Place_D7_in_D3
00001240  0243 00C0                265          ANDI #$00C0,D3
00001244  EC8B                     266          LSR.L #6,D3
00001246  0C43 0000                267          CMPI #0,D3
0000124A  6700 0016                268          BEQ Byte_Size_SubQ
0000124E  0C43 0001                269          CMPI #1,D3
00001252  6700 0020                270          BEQ Word_Size_SubQ
00001256  0C43 0002                271          CMPI #2,D3
0000125A  6700 0026                272          BEQ Long_Size_SubQ
0000125E  6000 0080                273          BRA SubQ_Error
00001262                           274  Byte_Size_SubQ
00001262  4EB9 00002948            275          JSR Byte_Print
00001268  383C 0054                276          MOVE #84,D4
0000126C  3C3C 0004                277          MOVE #4,D6
00001270  6000 001A                278          BRA After_Size_SubQ
00001274                           279  Word_Size_SubQ
00001274  4EB9 00002956            280          JSR Word_Print
0000127A  3C3C 000C                281          MOVE #12,D6
0000127E  6000 000C                282          BRA After_Size_SubQ
00001282                           283  Long_Size_SubQ
00001282  4EB9 00002964            284          JSR Long_Print
00001288  3C3C 001C                285          MOVE #28,D6
0000128C                           286  After_Size_SubQ
0000128C  4EB9 000027B8            287          JSR AddPoundSign
00001292  4EB9 000027AA            288          JSR AddHexCash
00001298  4EB9 000028D2            289          JSR Place_D7_in_D3
0000129E  0243 0E00                290          ANDI #$0E00,D3
000012A2  3A3C 0009                291          MOVE #9,D5
000012A6  EAAB                     292          LSR.L D5,D3
000012A8  0C43 0000                293          CMPI #0,D3
000012AC  6700 0006                294          BEQ ChangeToEight
000012B0  6000 0004                295          BRA After_Addition_Decision
000012B4                           296  ChangeToEight
000012B4  5043                     297          ADD #8,D3
000012B6                           298          
000012B6                           299  After_Addition_Decision
000012B6  3203                     300          MOVE D3,D1
000012B8  3606                     301          Move D6,D3
000012BA  4EB9 000029BC            302          JSR Add_Hex_String_To_Buffer
000012C0  4EB9 000028FC            303          JSR Add_Comma
000012C6  4242                     304          CLR D2
000012C8  3C3C 003C                305          MOVE #60,D6
000012CC  4EB9 00002374            306          JSR DestAddressingModeDetermine
000012D2  4246                     307          CLR D6
000012D4  D8C0                     308          ADDA D0,A4
000012D6  4EB9 00002694            309          JSR TrapTask13
000012DC  6000 FD3E                310          BRA start_Disassembly
000012E0                           311  SUBQ_Error
000012E0                           312          *JSR Print_Error
000012E0  4EB9 00002A06            313          JSR Error_Subroutine
000012E6  D8C0                     314          ADDA D0,A4
000012E8  6000 FD32                315          BRA start_Disassembly
000012EC                           316  
000012EC                           317  *********************************************************************************
000012EC                           318  * Method Name: Start_Sub_Disassembly
000012EC                           319  * Description: Begins processing of the decoding of a SUB instruction. It will load
000012EC                           320  *              appropriate ascii chars representing "SUB" into the string buffer and branch to another label to continue processing the 
000012EC                           321  *              instruction.
000012EC                           322  *
000012EC                           323  * Calling Convention: Neither
000012EC                           324  *
000012EC                           325  * Preconditions & Method Input:
000012EC                           326  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
000012EC                           327  *
000012EC                           328  * Postconditions & Output:
000012EC                           329  *   Appends to string buffer the correct assembly language equivalent to opcode field via "Start_String_Appending" call.
000012EC                           330  *
000012EC                           331  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "SUB")
000012EC                           332  *  D5 ??? (appears to be left over from earlier build)
000012EC                           333  *  D3 ??? (appears to be left over from earlier build)
000012EC                           334  Start_Sub_Disassembly
000012EC  3A03                     335          MOVE D3,D5
000012EE  45F9 00002B70            336          LEA SUB_op,A2
000012F4  4EB9 00002972            337          JSR Start_String_Appending
000012FA  6000 0082                338          BRA After_Decision_Add
000012FE                           339          
000012FE                           340  *********************************************************************************
000012FE                           341  * Method Name: Start_Add_Disassembly
000012FE                           342  * Description: Begins processing of the decoding of a ADD instruction. It will first check to see
000012FE                           343  *              if the instruction is in fact an ADDA instruction, using bit masks. If so, it will go
000012FE                           344  *              to the label "ADDA_Disassembly" to begin processing the different instruction, otherwise it will
000012FE                           345  *              continue processing the "ADD" instruction.
000012FE                           346  *
000012FE                           347  * Calling Convention: Neither
000012FE                           348  *
000012FE                           349  * Preconditions & Method Input:
000012FE                           350  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
000012FE                           351  *
000012FE                           352  * Postconditions & Output:
000012FE                           353  *   Branches to correct disassembly function based on condition of effective addressing field
000012FE                           354  *
000012FE                           355  *  D3 holds a copy of the current instruction opcode word for bit mask manipulation without data loss
000012FE                           356  *  D7 holds the current instruction opcode word   
000012FE                           357  Start_Add_Disassembly
000012FE  4EB9 000028D2            358          JSR Place_D7_in_D3
00001304  0243 00C0                359          ANDI #$00C0,D3
00001308  EC8B                     360          LSR.L #6,D3
0000130A  0C43 0003                361          CMPI #3,D3
0000130E  6600 0062                362          BNE ADD_Disassembly  * Checks for an ADDA instruction and branches if confirmed
00001312                           363          
00001312                           364  *********************************************************************************
00001312                           365  * Method Name: Start_ADDA_Disassembly
00001312                           366  * Description: Begins processing of the decoding of a ADDA instruction. It will load
00001312                           367  *              appropriate ascii chars representing "ADDA" into the string buffer and call the "DestAddressingModeDetermine"
00001312                           368  *              function to decode and build the effective addresses string, and will branch to "End_Add" to print and loop back 
00001312                           369  *              to "start_Disassembly"
00001312                           370  *
00001312                           371  * Calling Convention: Callee-Saved
00001312                           372  *
00001312                           373  * Preconditions & Method Input:
00001312                           374  *   Test for "ADD" instruction in "Start_Add_Disassembly" failed. A4 references the current instruction opcode word, as well as D7.
00001312                           375  *
00001312                           376  * Postconditions & Output:
00001312                           377  *   Appends to string buffer the correct assembly language equivalent to opcode instruction via "Start_String_Appending" call and prints to file.
00001312                           378  *
00001312                           379  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "ADDA")
00001312                           380  *  D7 holds the current instruction word
00001312                           381  *  D3 represents the width of the string hex value that will be converted to ascii (4: byte, 12: word, 28: long)
00001312                           382  *  A3 stores a flag to indicate the size of the operation (1: byte, 2: word, 3: long) to the "DestAddressingModeDetermine" function (only has significance for handling
00001312                           383  *  immediate addressing)
00001312                           384  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
00001312                           385  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001312                           386  *  the function to know which addressing modes to forbid for this instruction.
00001312                           387  ADDA_Disassembly
00001312  45F9 00002B6B            388          LEA ADDA_op,A2
00001318  4EB9 00002972            389          JSR Start_String_Appending
0000131E  0807 0008                390          BTST #8,D7
00001322  6600 001A                391          BNE Long_ADDA
00001326                           392  Word_ADDA
00001326  45F9 00002B87            393          LEA Word_Size,A2
0000132C  367C 0002                394          MOVE #2,A3
00001330  363C 000C                395          MOVE #12,D3
00001334  4EB9 00002972            396          JSR Start_String_Appending
0000133A  6000 0016                397          BRA Continue_ADDA
0000133E                           398  Long_ADDA
0000133E  45F9 00002B8F            399          LEA Long_Size,A2
00001344  367C 0003                400          MOVE #3,A3
00001348  363C 001C                401          MOVE #28,D3
0000134C  4EB9 00002972            402          JSR Start_String_Appending
00001352                           403  Continue_ADDA
00001352  4242                     404          CLR D2
00001354  4EB9 00002374            405          JSR DestAddressingModeDetermine
0000135A  383C 0001                406          MOVE #1,D4  * tells the R_Destination function that it wants an address register printed
0000135E  343C 0001                407          MOVE #1,D2  * tells the R_Desination function that it wants a destination (bits 9-11) register printed)
00001362  4EB9 000028FC            408          JSR Add_Comma
00001368  4EB9 00002298            409          JSR R_Destination
0000136E  6000 00A6                410          BRA End_Add
00001372                           411         
00001372                           412  *********************************************************************************
00001372                           413  * Method Name: ADD_Disassembly
00001372                           414  * Description: Begins processing of the decoding of a ADD instruction. It will load
00001372                           415  *              appropriate ascii chars representing "ADD" into the string buffer and call the "DestAddressingModeDetermine"
00001372                           416  *              function to decode and build the effective addresses string, and will branch to "End_Add" to print and loop back 
00001372                           417  *              to "start_Disassembly". If size determined is invalid, then branch to "Add_Error" to print "XXXXXXXX DATA YYYY" and clear the string 
00001372                           418  *              buffer.
00001372                           419  *
00001372                           420  * Calling Convention: Callee-Saved
00001372                           421  *
00001372                           422  * Preconditions & Method Input:
00001372                           423  *   Is called by the "Start_Add_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001372                           424  *
00001372                           425  * Postconditions & Output:
00001372                           426  *   Appends to string buffer the correct assembly language equivalent to opcode instruction via "Start_String_Appending" call and prints to file.
00001372                           427  *
00001372                           428  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "ADD")
00001372                           429  *  D7 holds the current instruction word
00001372                           430  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data (determines size of operation here)
00001372                           431  *  A3 stores a flag to indicate the size of the operation (1: byte, 2: word, 3: long) to the "DestAddressingModeDetermine" function (only has significance for handling
00001372                           432  *  immediate addressing)
00001372                           433  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
00001372                           434  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001372                           435  *  the function to know which addressing modes to forbid for this instruction.
00001372                           436  *  A4 points to the current instruction opcode word in memory
00001372                           437  ADD_Disassembly
00001372  45F9 00002B67            438          LEA Add_op,A2
00001378  4EB9 00002972            439          JSR Start_String_Appending
0000137E                           440          
0000137E                           441  After_Decision_Add
0000137E  4EB9 000028D2            442          JSR Place_D7_in_D3
00001384  0243 00C0                443          ANDI #$00C0,D3
00001388  EC8B                     444          LSR.L #6,D3
0000138A  0C43 0000                445          CMPI #0,D3
0000138E  6700 0016                446          BEQ Byte_Size_Add
00001392  0C43 0001                447          CMPI #1,D3
00001396  6700 001C                448          BEQ Word_Size_Add
0000139A  0C43 0002                449          CMPI #2,D3
0000139E  6700 0022                450          BEQ Long_Size_Add
000013A2  6000 007E                451          BRA Add_Error
000013A6                           452  Byte_Size_Add
000013A6  4EB9 00002948            453          JSR Byte_Print
000013AC  367C 0001                454          MOVE #1,A3
000013B0  6000 001A                455          BRA Check_Order_Add
000013B4                           456          
000013B4                           457  Word_Size_Add
000013B4  4EB9 00002956            458          JSR Word_Print
000013BA  367C 0002                459          MOVE #2,A3
000013BE  6000 000C                460          BRA Check_Order_Add
000013C2                           461  
000013C2                           462  Long_Size_Add
000013C2  4EB9 00002964            463          JSR Long_Print
000013C8  367C 0003                464          MOVE #3,A3
000013CC                           465  
000013CC                           466  Check_Order_Add
000013CC  4242                     467          CLR D2
000013CE  0807 0008                468          BTST #8,D7
000013D2  6600 0024                469          BNE EffectiveAdd_Add_First
000013D6  6000 0002                470          BRA Data_Add_First
000013DA                           471  Data_Add_First
000013DA  4242                     472          CLR D2
000013DC  4EB9 00002374            473          JSR DestAddressingModeDetermine
000013E2  4EB9 000028FC            474          JSR Add_Comma
000013E8  343C 0001                475          MOVE #1,D2
000013EC  4EB9 00002298            476          JSR R_Destination
000013F2  4245                     477          CLR D5
000013F4  6000 0020                478          BRA End_Add
000013F8                           479  EffectiveAdd_Add_First
000013F8  343C 0001                480          MOVE #1,D2
000013FC  4EB9 00002298            481          JSR R_Destination
00001402  4EB9 000028FC            482          JSR Add_Comma
00001408  4242                     483          CLR D2
0000140A  383C 0194                484          MOVE #404,D4
0000140E  4EB9 00002374            485          JSR DestAddressingModeDetermine
00001414  4245                     486          CLR D5
00001416                           487  
00001416                           488  End_Add
00001416  D8C0                     489          ADDA D0,A4
00001418  4EB9 00002694            490          JSR TrapTask13
0000141E  6000 FBFC                491          BRA start_Disassembly
00001422                           492  
00001422                           493  Add_Error
00001422  4EB9 00002A06            494          JSR Error_Subroutine
00001428  D8C0                     495          ADDA D0,A4
0000142A  6000 FBF0                496          BRA start_Disassembly
0000142E                           497  
0000142E                           498  
0000142E                           499  *********************************************************************************
0000142E                           500  * Method Name: Start_ORI_Disassembly
0000142E                           501  * Description: Begins processing of the decoding of a ORI instruction. It will load
0000142E                           502  *              appropriate ascii chars into the string buffer, call the "DestAddressingModeDetermine" function to determine the destination effective address, 
0000142E                           503  *              and print the appropriate string represented assembly language ORI instruction.
0000142E                           504  *
0000142E                           505  * Calling Convention: Callee-Saved
0000142E                           506  *
0000142E                           507  * Preconditions & Method Input:
0000142E                           508  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
0000142E                           509  *
0000142E                           510  * Postconditions & Output:
0000142E                           511  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
0000142E                           512  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
0000142E                           513  *   necessary amount given current instruction format.
0000142E                           514  *
0000142E                           515  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "ORI")
0000142E                           516  *  A3 stores a flag to indicate the size of the operation (1: byte, 2: word, 3: long) to the "DestAddressingModeDetermine" function (only has significance for handling
0000142E                           517  *  immediate addressing)
0000142E                           518  *  A4 points to the current instruction opcode in memory
0000142E                           519  *  D7 holds the current instruction opcode word
0000142E                           520  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
0000142E                           521  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
0000142E                           522  *  the function to know which addressing modes to forbid for this instruction.
0000142E                           523  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
0000142E                           524  *  D0 stores the amount by which A4 will be incremented after the completion of this function
0000142E                           525  *********************************************************************************
0000142E                           526  Start_ORI_Disassembly
0000142E  45F9 00002B63            527          LEA ORI_op,A2
00001434  4EB9 00002972            528          JSR Start_String_Appending
0000143A  4EB9 000028D2            529          JSR Place_D7_in_D3
00001440  0243 00C0                530          ANDI #$00C0,D3
00001444  EC8B                     531          LSR.L #6,D3
00001446  0C43 0000                532          CMPI #0,D3
0000144A  6700 0016                533          BEQ Byte_ORI
0000144E  0C43 0001                534          CMPI #1,D3
00001452  6700 0020                535          BEQ Word_ORI
00001456  0C43 0002                536          CMPI #2,D3
0000145A  6700 002A                537          BEQ Long_ORI
0000145E  6000 006E                538          BRA ORI_Error
00001462                           539  Byte_ORI
00001462  4EB9 00002948            540          JSR Byte_Print
00001468  367C 0001                541          MOVE #1,A3
0000146C  363C 0004                542          MOVE #4,D3
00001470  6000 0022                543          BRA After_Size_ORI
00001474                           544          
00001474                           545  Word_ORI
00001474  4EB9 00002956            546          JSR Word_Print
0000147A  367C 0002                547          MOVE #2,A3
0000147E  363C 000C                548          MOVE #12,D3
00001482  6000 0010                549          BRA After_Size_ORI
00001486                           550  
00001486                           551  Long_ORI
00001486  4EB9 00002964            552          JSR Long_Print
0000148C  363C 001C                553          MOVE #28,D3
00001490  367C 0003                554          MOVE #3,A3   
00001494                           555  
00001494                           556  After_Size_ORI
00001494  4EB9 00002856            557          JSR IsolateInstrOperands
0000149A  4EB9 000027B8            558          JSR AddPoundSign
000014A0  4EB9 000027AA            559          JSR AddHexCash
000014A6  4EB9 000029BC            560          JSR Add_Hex_String_To_Buffer
000014AC  2206                     561          MOVE.L D6,D1
000014AE  4EB9 000028FC            562          JSR Add_Comma
000014B4  4242                     563          CLR D2
000014B6  383C 0063                564          MOVE #99,D4  * indicate that the function call came from an ORI instruction to DestAddressingModeDetermine
000014BA  4281                     565          CLR.L D1
000014BC  4EB9 00002374            566          JSR DestAddressingModeDetermine
000014C2  D8C0                     567          ADDA D0,A4
000014C4  4EB9 00002694            568          JSR TrapTask13
000014CA  6000 FB50                569          BRA start_Disassembly
000014CE                           570          
000014CE                           571  ORI_Error
000014CE  4EB9 00002A06            572          JSR Error_Subroutine
000014D4  D8C0                     573          ADDA D0,A4
000014D6  6000 FB44                574          BRA start_Disassembly
000014DA                           575          
000014DA                           576  
000014DA                           577  *********************************************************************************
000014DA                           578  * Method Name: Start_OR_Disassembly
000014DA                           579  * Description: Begins processing of the decoding of a OR instruction. It will load
000014DA                           580  *              appropriate ascii chars into the string buffer, call the "DestAddressingModeDetermine" function to determine the destination effective address, 
000014DA                           581  *              and print the appropriate string represented assembly language OR instruction.
000014DA                           582  *
000014DA                           583  * Calling Convention: Callee-Saved
000014DA                           584  *
000014DA                           585  * Preconditions & Method Input:
000014DA                           586  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
000014DA                           587  *
000014DA                           588  * Postconditions & Output:
000014DA                           589  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
000014DA                           590  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
000014DA                           591  *   necessary amount given current instruction format.
000014DA                           592  *
000014DA                           593  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "OR")
000014DA                           594  *  A3 stores a flag to indicate the size of the operation (1: byte, 2: word, 3: long) to the "DestAddressingModeDetermine" function (only has significance for handling
000014DA                           595  *  immediate addressing)
000014DA                           596  *  A4 points to the current instruction opcode in memory
000014DA                           597  *  D7 holds the current instruction opcode word
000014DA                           598  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
000014DA                           599  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
000014DA                           600  *  the function to know which addressing modes to forbid for this instruction.
000014DA                           601  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
000014DA                           602  *  D0 stores the amount by which A4 will be incremented after the completion of this function
000014DA                           603  *********************************************************************************
000014DA                           604  Start_OR_Disassembly
000014DA  45F9 00002B60            605          LEA OR_op,A2
000014E0  4EB9 00002972            606          JSR Start_String_Appending
000014E6  4EB9 000028D2            607          JSR Place_D7_in_D3
000014EC  0243 00C0                608          ANDI #$00C0,D3
000014F0  EC8B                     609          LSR.L #6,D3
000014F2  0C43 0000                610          CMPI #0,D3
000014F6  6700 0016                611          BEQ Byte_Size_OR
000014FA  0C43 0001                612          CMPI #1,D3
000014FE  6700 001C                613          BEQ Word_Size_OR
00001502  0C43 0002                614          CMPI #2,D3
00001506  6700 0022                615          BEQ Long_Size_OR
0000150A  6000 0080                616          BRA OR_Error
0000150E                           617  Byte_Size_OR
0000150E  4EB9 00002948            618          JSR Byte_Print
00001514  367C 0001                619          MOVE #1,A3
00001518  6000 001A                620          BRA After_Size_OR
0000151C                           621  Word_Size_OR
0000151C  4EB9 00002956            622          JSR Word_Print
00001522  367C 0002                623          MOVE #2,A3
00001526  6000 000C                624          BRA After_Size_OR
0000152A                           625  Long_Size_OR
0000152A  4EB9 00002964            626          JSR Long_Print
00001530  367C 0003                627          MOVE #3,A3
00001534                           628  After_Size_OR
00001534  0807 0008                629          BTST #8,D7
00001538  6600 0006                630          BNE Print_Data_Reg_First
0000153C  6000 0024                631          BRA Print_Effective_Address_First
00001540                           632  Print_Data_Reg_First
00001540  4244                     633          CLR D4
00001542  343C 0001                634          MOVE #1,D2
00001546  4EB9 00002298            635          JSR R_Destination
0000154C  4EB9 000028FC            636          JSR Add_Comma
00001552  4242                     637          CLR D2
00001554  383C 005C                638          MOVE #92,D4 * signals to DestAddressingModeDetermine that the function call came from an OR instruction with effective address as destination
00001558  4EB9 00002374            639          JSR DestAddressingModeDetermine
0000155E  6000 0020                640          BRA After_OR_Decision
00001562                           641  Print_Effective_Address_First
00001562  4242                     642          CLR D2
00001564  383C 0062                643          MOVE #98,D4 * signals to DestAddressingModeDetermine that the function call came from an OR instruction with effective address as source
00001568  4EB9 00002374            644          JSR DestAddressingModeDetermine
0000156E  4EB9 000028FC            645          JSR Add_Comma
00001574  4242                     646          CLR D2
00001576  343C 0001                647          MOVE #1,D2
0000157A  4EB9 00002298            648          JSR R_Destination
00001580                           649          
00001580                           650  After_OR_Decision
00001580  D8C0                     651          ADDA D0,A4
00001582  4EB9 00002694            652          JSR TrapTask13
00001588  6000 FA92                653          BRA start_Disassembly
0000158C                           654          
0000158C                           655  OR_Error
0000158C  4EB9 00002A06            656          JSR Error_Subroutine
00001592  D8C0                     657          ADDA D0,A4
00001594  6000 FA86                658          BRA start_Disassembly
00001598                           659          
00001598                           660  *********************************************************************************
00001598                           661  * Method Name: Start_Shifting_Disassembly
00001598                           662  * Description: Begins processing of the decoding of various shift instructions (LSL,LSR,ASL,ASR,ROL,ROR). It will determine which subtype the instruction
00001598                           663  *              is via bit masking as well as what operand format it comes in (i.e. Dn,Dn or #<data>,Dy, or <ea>). Appropriate ascii chars will 
00001598                           664  *              then be put into the string buffer, call the "DestAddressingModeDetermine" function to determine the effective addresses, 
00001598                           665  *              and print the appropriate string represented assembly language shifting instruction (any one of them).
00001598                           666  *
00001598                           667  * Calling Convention: Callee-Saved
00001598                           668  *
00001598                           669  * Preconditions & Method Input:
00001598                           670  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001598                           671  *
00001598                           672  * Postconditions & Output:
00001598                           673  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001598                           674  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001598                           675  *   necessary amount given current instruction format.
00001598                           676  *
00001598                           677  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "LSL","LSR","ASR","ASL","ROR","ROL")
00001598                           678  *  A4 points to the current instruction opcode in memory
00001598                           679  *  D7 holds the current instruction opcode word
00001598                           680  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
00001598                           681  *  D6 temporarily holding the value D3 would hold when D3 needs to be used for another bit masking purpose at a particular moment
00001598                           682  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001598                           683  *  the function to know which addressing modes to forbid for this instruction.
00001598                           684  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
00001598                           685  *  D0 stores the amount by which A4 will be incremented after the completion of this function
00001598                           686  *********************************************************************************
00001598                           687  Start_Shifting_Disassembly
00001598  4EB9 000028D2            688          JSR Place_D7_in_D3
0000159E  0243 FFC0                689          ANDI #$FFC0,D3
000015A2  EC8B                     690          LSR.L #6,D3
000015A4  0C43 038B                691          CMPI #907,D3
000015A8  6700 00AA                692          BEQ Memory_Logical_Shift_Right
000015AC  0C43 038F                693          CMPI #911,D3
000015B0  6700 00B8                694          BEQ Memory_Logical_Shift_Left
000015B4  0C43 0383                695          CMPI #899,D3
000015B8  6700 0042                696          BEQ Memory_Arithmetic_Shift_Right
000015BC  0C43 0387                697          CMPI #903,D3
000015C0  6700 0050                698          BEQ Memory_Arithmetic_Shift_Left
000015C4  0C43 039B                699          CMPI #923,D3
000015C8  6700 0074                700          BEQ Memory_Roll_Right
000015CC  0C43 039F                701          CMPI #927,D3
000015D0  6700 0056                702          BEQ Memory_Roll_Left
000015D4  4EB9 000028D2            703          JSR Place_D7_in_D3
000015DA  0243 0018                704          ANDI #$0018,D3
000015DE  E64B                     705          LSR #3,D3
000015E0  0C43 0001                706          CMPI #1,D3
000015E4  6700 00AE                707          BEQ Register_Shift
000015E8  0C43 0000                708          CMPI #0,D3
000015EC  6700 00A6                709          BEQ Register_Shift
000015F0  0C43 0003                710          CMPI #3,D3
000015F4  6700 009E                711          BEQ Register_Shift
000015F8  6000 0206                712          BRA Shift_Error
000015FC                           713  Memory_Arithmetic_Shift_Right
000015FC  45F9 00002B50            714          LEA ASR_op,A2
00001602  4EB9 00002972            715          JSR Start_String_Appending
00001608  4EB9 0000290A            716          JSR Add_Space
0000160E  6000 006C                717          BRA ContinueMemoryShift
00001612                           718          
00001612                           719  Memory_Arithmetic_Shift_Left
00001612  45F9 00002B4C            720          LEA ASL_op,A2
00001618  4EB9 00002972            721          JSR Start_String_Appending
0000161E  4EB9 0000290A            722          JSR Add_Space
00001624  6000 0056                723          BRA ContinueMemoryShift
00001628                           724  
00001628                           725  Memory_Roll_Left
00001628  45F9 00002B54            726          LEA ROL_op,A2
0000162E  4EB9 00002972            727          JSR Start_String_Appending
00001634  4EB9 0000290A            728          JSR Add_Space
0000163A  6000 0040                729          BRA ContinueMemoryShift
0000163E                           730          
0000163E                           731  Memory_Roll_Right
0000163E  45F9 00002B58            732          LEA ROR_op,A2
00001644  4EB9 00002972            733          JSR Start_String_Appending
0000164A  4EB9 0000290A            734          JSR Add_Space
00001650  6000 002A                735          BRA ContinueMemoryShift
00001654                           736  
00001654                           737  Memory_Logical_Shift_Right
00001654  45F9 00002B48            738          LEA LSR_op,A2
0000165A  4EB9 00002972            739          JSR Start_String_Appending
00001660  4EB9 0000290A            740          JSR Add_Space
00001666  6000 0014                741          BRA ContinueMemoryShift
0000166A                           742  Memory_Logical_Shift_Left
0000166A  45F9 00002B44            743          LEA LSL_op,A2
00001670  4EB9 00002972            744          JSR Start_String_Appending
00001676  4EB9 0000290A            745          JSR Add_Space
0000167C                           746  ContinueMemoryShift
0000167C  4242                     747          CLR D2
0000167E  383C 001F                748          MOVE #31,D4     * flag indicates that function call came from a LSd Memory Shift operation to DestAddressingModeDetermine
00001682  4EB9 00002374            749          JSR DestAddressingModeDetermine
00001688  D8C0                     750          ADDA D0,A4
0000168A  4EB9 00002694            751          JSR TrapTask13
00001690  6000 F98A                752          BRA start_Disassembly
00001694                           753         * ANDI #$0100,D3
00001694                           754         * LSR.L #8,D3
00001694                           755         * CMPI #0,D3
00001694                           756         * BEQ PrintLSR
00001694                           757     
00001694                           758  Register_Shift
00001694  3C03                     759          MOVE D3,D6
00001696  4EB9 000028D2            760          JSR Place_D7_in_D3
0000169C  0243 0100                761          ANDI #$0100,D3
000016A0  E08B                     762          LSR.L #8,D3
000016A2  0C43 0001                763          CMPI #1,D3
000016A6  6700 0042                764          BEQ Register_Left
000016AA                           765  Register_Right
000016AA  0C46 0000                766          CMPI #0,D6
000016AE  6700 002A                767          BEQ Print_ArithmeticR
000016B2  0C46 0003                768          CMPI #3,D6
000016B6  6700 0012                769          BEQ Print_RORR
000016BA  45F9 00002B48            770          LEA LSR_op,A2
000016C0  4EB9 00002972            771          JSR Start_String_Appending
000016C6  6000 005E                772          BRA ProcessRegisterShift
000016CA                           773          
000016CA                           774  Print_RORR
000016CA  45F9 00002B58            775          LEA ROR_op,A2
000016D0  4EB9 00002972            776          JSR Start_String_Appending
000016D6  6000 004E                777          BRA ProcessRegisterShift
000016DA                           778          
000016DA                           779  Print_ArithmeticR
000016DA  45F9 00002B50            780          LEA ASR_op,A2
000016E0  4EB9 00002972            781          JSR Start_String_Appending
000016E6  6000 003E                782          BRA ProcessRegisterShift
000016EA                           783          
000016EA                           784  Register_Left
000016EA  0C46 0000                785          CMPI #0,D6
000016EE  6700 001A                786          BEQ Print_ArithmeticL
000016F2  0C46 0003                787          CMPI #3,D6
000016F6  6700 0022                788          BEQ Print_RORL
000016FA  45F9 00002B44            789          LEA LSL_op,A2
00001700  4EB9 00002972            790          JSR Start_String_Appending
00001706  6000 001E                791          BRA ProcessRegisterShift
0000170A                           792  Print_ArithmeticL
0000170A  45F9 00002B4C            793          LEA ASL_op,A2
00001710  4EB9 00002972            794          JSR Start_String_Appending
00001716  6000 000E                795          BRA ProcessRegisterShift
0000171A                           796          
0000171A                           797  Print_RORL
0000171A  45F9 00002B54            798          LEA ROL_op,A2
00001720  4EB9 00002972            799          JSR Start_String_Appending
00001726                           800          
00001726                           801  ProcessRegisterShift
00001726  4EB9 000028D2            802          JSR Place_D7_in_D3
0000172C  0243 00C0                803          ANDI #$00C0,D3
00001730  EC8B                     804          LSR.L #6,D3
00001732  0C43 0000                805          CMPI #0,D3
00001736  6700 0016                806          BEQ Reg_Byte
0000173A  0C43 0001                807          CMPI #1,D3
0000173E  6700 001C                808          BEQ Reg_Word
00001742  0C43 0002                809          CMPI #2,D3
00001746  6700 0022                810          BEQ Reg_Long
0000174A  6000 00B4                811          BRA Shift_Error
0000174E                           812  Reg_Byte
0000174E  45F9 00002B8B            813          LEA Byte_Size,A2
00001754  3A3C 0004                814          MOVE #4,D5
00001758  6000 001A                815          BRA ProcessRegister
0000175C                           816  Reg_Word
0000175C  45F9 00002B87            817          LEA Word_Size,A2
00001762  3A3C 000C                818          MOVE #12,D5
00001766  6000 000C                819          BRA ProcessRegister
0000176A                           820  Reg_Long
0000176A  45F9 00002B8F            821          LEA Long_Size,A2
00001770  3A3C 001C                822          MOVE #28,D5
00001774                           823  ProcessRegister
00001774  4EB9 00002972            824          JSR Start_String_Appending
0000177A  4EB9 000028D2            825          JSR Place_D7_in_D3
00001780  0243 0020                826          ANDI #$0020,D3
00001784  EA8B                     827          LSR.L #5,D3
00001786  0C43 0001                828          CMPI #1,D3
0000178A  6700 0042                829          BEQ RegisterSpecified
0000178E                           830  RegisterImmediate
0000178E  4EB9 000028D2            831          JSR Place_D7_in_D3
00001794  4EB9 00002934            832          JSR LSd_Register_Mask_Isolate
0000179A  4EB9 000027B8            833          JSR AddPoundSign
000017A0  4EB9 000027AA            834          JSR AddHexCash
000017A6  0C43 0000                835          CMPI #0,D3
000017AA  6600 0006                836          BNE AfterEight
000017AE                           837  ConvertFromEight
000017AE  363C 0008                838          MOVE #8,D3
000017B2                           839  AfterEight
000017B2  3203                     840          MOVE D3,D1
000017B4  3605                     841          MOVE D5,D3
000017B6  4EB9 000029BC            842          JSR Add_Hex_String_To_Buffer
000017BC  4EB9 000028FC            843          JSR Add_Comma
000017C2  4242                     844          CLR D2
000017C4  4EB9 00002298            845          JSR R_Destination
000017CA  6000 0028                846          BRA EndShift
000017CE                           847  RegisterSpecified
000017CE  4EB9 000028D2            848          JSR Place_D7_in_D3
000017D4  4EB9 00002934            849          JSR LSd_Register_Mask_Isolate
000017DA  343C 0001                850          MOVE #1,D2
000017DE  4244                     851          CLR D4
000017E0  4EB9 00002298            852          JSR R_Destination
000017E6  4EB9 000028FC            853          JSR Add_Comma
000017EC  4242                     854          CLR D2
000017EE  4EB9 00002298            855          JSR R_Destination
000017F4                           856  EndShift
000017F4  D8C0                     857          ADDA D0,A4
000017F6  4EB9 00002694            858          JSR TrapTask13
000017FC  6000 F81E                859          BRA start_Disassembly
00001800                           860  Shift_Error
00001800  4EB9 00002A06            861          JSR Error_Subroutine
00001806  D8C0                     862          ADDA D0,A4
00001808  6000 F812                863          BRA start_Disassembly
0000180C                           864          
0000180C                           865  
0000180C                           866  *********************************************************************************
0000180C                           867  * Method Name: Start_CMPI_Disassembly
0000180C                           868  * Description: Begins processing of the decoding of a CMPI instruction. Appropriate ascii chars will then be put into the string buffer, call 
0000180C                           869  *              the "DestAddressingModeDetermine" function to determine the effective addresses, and print the appropriate string 
0000180C                           870  *              represented assembly language CMPI instruction.
0000180C                           871  *
0000180C                           872  * Calling Convention: Callee-Saved
0000180C                           873  *
0000180C                           874  * Preconditions & Method Input:
0000180C                           875  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
0000180C                           876  *
0000180C                           877  * Postconditions & Output:
0000180C                           878  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
0000180C                           879  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
0000180C                           880  *   necessary amount given current instruction format.
0000180C                           881  *
0000180C                           882  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "CMPI")
0000180C                           883  *  A4 points to the current instruction opcode in memory
0000180C                           884  *  A6 points to a displacement point from the current instruction opcode address (allows fetching of word operands without changing A4)
0000180C                           885  *  D7 holds the current instruction opcode word
0000180C                           886  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
0000180C                           887  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
0000180C                           888  *  the function to know which addressing modes to forbid for this instruction.
0000180C                           889  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
0000180C                           890  *  D0 stores the amount by which A4 will be incremented after the completion of this function
0000180C                           891  *********************************************************************************
0000180C                           892  Start_CMPI_Disassembly
0000180C  45F9 00002B3F            893          LEA CMPI_op,A2
00001812  4EB9 00002972            894          JSR Start_String_Appending
00001818  4EB9 000028D2            895          JSR Place_D7_in_D3
0000181E  0243 00C0                896          ANDI #$00C0,D3
00001822  EC8B                     897          LSR.L #6,D3
00001824  0C43 0000                898          CMPI #0,D3
00001828  6700 0016                899          BEQ CMPI_Byte
0000182C  0C43 0001                900          CMPI #1,D3
00001830  6700 0040                901          BEQ CMPI_Word
00001834  0C43 0002                902          CMPI #2,D3
00001838  6700 0066                903          BEQ CMPI_Long
0000183C  6000 00B6                904          BRA CMPI_Error
00001840                           905  CMPI_Byte
00001840  45F9 00002B8B            906          LEA Byte_Size,A2
00001846  4EB9 00002972            907          JSR Start_String_Appending
0000184C  2C4C                     908          MOVE.L A4,A6
0000184E  544E                     909          ADDA #2,A6
00001850  5440                     910          ADDI #2,D0
00001852  3216                     911          MOVE.W (A6),D1
00001854  0241 00FF                912          ANDI.W #$00FF,D1
00001858  4EB9 000027B8            913          JSR AddPoundSign
0000185E  4EB9 000027AA            914          JSR AddHexCash
00001864  363C 0004                915          MOVE #4,D3
00001868  4EB9 000029BC            916          JSR Add_Hex_String_To_Buffer
0000186E  6000 0064                917          BRA Process_CMPI
00001872                           918  CMPI_Word
00001872  45F9 00002B87            919          LEA Word_Size,A2
00001878  4EB9 00002972            920          JSR Start_String_Appending
0000187E  2C4C                     921          MOVE.L A4,A6
00001880  544E                     922          ADDA #2,A6
00001882  5440                     923          ADDI #2,D0
00001884  3216                     924          MOVE.W (A6),D1
00001886  4EB9 000027B8            925          JSR AddPoundSign
0000188C  4EB9 000027AA            926          JSR AddHexCash
00001892  363C 000C                927          MOVE #12,D3
00001896  4EB9 000029BC            928          JSR Add_Hex_String_To_Buffer
0000189C  6000 0036                929          BRA Process_CMPI
000018A0                           930  CMPI_Long
000018A0  45F9 00002B8F            931          LEA Long_Size,A2
000018A6  4EB9 00002972            932          JSR Start_String_Appending
000018AC  2C4C                     933          MOVE.L A4,A6
000018AE  544E                     934          ADDA #2,A6
000018B0  3216                     935          MOVE.W (A6),D1
000018B2  544E                     936          ADDA #2,A6
000018B4  5840                     937          ADDI #4,D0
000018B6  3A3C 0010                938          MOVE #16,D5
000018BA  EBA9                     939          LSL.L D5,D1
000018BC  3216                     940          MOVE.W (A6),D1
000018BE  4EB9 000027B8            941          JSR AddPoundSign
000018C4  4EB9 000027AA            942          JSR AddHexCash
000018CA  363C 001C                943          MOVE #28,D3
000018CE  4EB9 000029BC            944          JSR Add_Hex_String_To_Buffer
000018D4                           945  Process_CMPI
000018D4  4242                     946          CLR D2                
000018D6  383C 001B                947          MOVE #27,D4
000018DA  4EB9 000028FC            948          JSR Add_Comma
000018E0  4281                     949          CLR.L D1
000018E2  4EB9 00002374            950          JSR DestAddressingModeDetermine
000018E8  D8C0                     951          ADDA D0,A4
000018EA  4EB9 00002694            952          JSR TrapTask13
000018F0  6000 F72A                953          BRA start_Disassembly
000018F4                           954          
000018F4                           955  CMPI_Error
000018F4  4EB9 00002A06            956          JSR Error_Subroutine
000018FA  D8C0                     957          ADDA D0,A4
000018FC  6000 F71E                958          BRA start_Disassembly
00001900                           959          
00001900                           960  
00001900                           961  *********************************************************************************
00001900                           962  * Method Name: Start_CMP_Disassembly
00001900                           963  * Description: Begins processing of the decoding of a CMP instruction. Can branch to an EOR instruction if specific fields in the opcode
00001900                           964  *              line up with an EOR interpretation. This is a result of shared fields between the two instructions. 
00001900                           965  *              Appropriate ascii chars will then be put into the string buffer, call the "DestAddressingModeDetermine" function to 
00001900                           966  *              determine the effective addresses, and print the appropriate string represented assembly language CMP instruction.
00001900                           967  *
00001900                           968  * Calling Convention: Callee-Saved
00001900                           969  *
00001900                           970  * Preconditions & Method Input:
00001900                           971  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001900                           972  *
00001900                           973  * Postconditions & Output:
00001900                           974  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001900                           975  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001900                           976  *   necessary amount given current instruction format. Could also branch to "Start_EOR_Disassembly", if EOR condition check passes.
00001900                           977  *
00001900                           978  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "CMP")
00001900                           979  *  A4 points to the current instruction opcode in memory
00001900                           980  *  D7 holds the current instruction opcode word
00001900                           981  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
00001900                           982  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001900                           983  *  the function to know which addressing modes to forbid for this instruction.
00001900                           984  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
00001900                           985  *  D0 stores the amount by which A4 will be incremented after the completion of this function
00001900                           986  *********************************************************************************
00001900                           987  Start_CMP_Disassembly
00001900  0807 0008                988          BTST #8,D7
00001904  6600 00AC                989          BNE Start_EOR_Disassembly * checks to see if instruction is actually an EOR instruction
00001908  45F9 00002B3B            990          LEA CMP_op,A2
0000190E  4EB9 00002972            991          JSR Start_String_Appending
00001914  4EB9 000028D2            992          JSR Place_D7_in_D3
0000191A  0283 000001C0            993          ANDI.L #$01C0,D3
00001920  3A3C 0006                994          MOVE #6,D5
00001924  EAAB                     995          LSR.L D5,D3
00001926  0C43 0000                996          CMPI #0,D3
0000192A  6700 0016                997          BEQ CMP_Byte
0000192E  0C43 0001                998          CMPI #1,D3
00001932  6700 001E                999          BEQ CMP_Word
00001936  0C43 0002               1000          CMPI #2,D3
0000193A  6700 0026               1001          BEQ CMP_Long
0000193E  6000 0066               1002          BRA CMP_Error
00001942                          1003  CMP_Byte
00001942  45F9 00002B8B           1004          LEA Byte_Size,A2
00001948  4EB9 00002972           1005          JSR Start_String_Appending
0000194E  6000 001E               1006          BRA Process_CMP
00001952                          1007  CMP_Word
00001952  45F9 00002B87           1008          LEA Word_Size,A2
00001958  4EB9 00002972           1009          JSR Start_String_Appending
0000195E  6000 000E               1010          BRA Process_CMP
00001962                          1011  CMP_Long
00001962  45F9 00002B8F           1012          LEA Long_Size,A2
00001968  4EB9 00002972           1013          JSR Start_String_Appending
0000196E                          1014  Process_CMP
0000196E  4242                    1015          CLR D2
00001970  383C 0015               1016          MOVE #21,D4 * mark as from CMP instruction for proper data register direct processing in the DestAddressingModeDetermine function
00001974  4EB9 00002374           1017          JSR DestAddressingModeDetermine
0000197A                          1018          *JSR Print_Data_Register
0000197A  4EB9 000028D2           1019          JSR Place_D7_in_D3
00001980  0243 0E00               1020          ANDI #$0E00,D3
00001984  3A3C 0009               1021          MOVE #9,D5
00001988  EAAB                    1022          LSR.L D5,D3
0000198A  4281                    1023          CLR.L D1
0000198C  3A03                    1024          MOVE D3,D5
0000198E  4EB9 000028FC           1025          JSR Add_Comma
00001994  4EB9 000021AE           1026          JSR CallDPrintNumber
0000199A  D8C0                    1027          ADDA D0,A4
0000199C  4EB9 00002694           1028          JSR TrapTask13
000019A2  6000 F678               1029          BRA start_Disassembly
000019A6                          1030          
000019A6                          1031  CMP_Error
000019A6  4EB9 00002A06           1032          JSR Error_Subroutine
000019AC  D8C0                    1033          ADDA D0,A4
000019AE  6000 F66C               1034          BRA start_Disassembly
000019B2                          1035  
000019B2                          1036  *********************************************************************************
000019B2                          1037  * Method Name: Start_EOR_Disassembly
000019B2                          1038  * Description: Begins processing of the decoding of a EOR instruction. Appropriate ascii chars will then be put into the string buffer, call 
000019B2                          1039  *              the "DestAddressingModeDetermine" function to determine the effective addresses, and print the appropriate string 
000019B2                          1040  *              represented assembly language EOR instruction.
000019B2                          1041  *
000019B2                          1042  * Calling Convention: Callee-Saved
000019B2                          1043  *
000019B2                          1044  * Preconditions & Method Input:
000019B2                          1045  *   Is called by the "Start_CMP_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
000019B2                          1046  *
000019B2                          1047  * Postconditions & Output:
000019B2                          1048  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
000019B2                          1049  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
000019B2                          1050  *   necessary amount given current instruction format.
000019B2                          1051  *
000019B2                          1052  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "EOR")
000019B2                          1053  *  A4 points to the current instruction opcode in memory
000019B2                          1054  *  D7 holds the current instruction opcode word
000019B2                          1055  *  D6 stores a flag that notifies the "DestAddressingModeDetermine" function that the function calling it is processing a destination operand (#60 indicates this state)
000019B2                          1056  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data
000019B2                          1057  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
000019B2                          1058  *  the function to know which addressing modes to forbid for this instruction.
000019B2                          1059  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
000019B2                          1060  *  D0 stores the amount by which A4 will be incremented after the completion of this function
000019B2                          1061  *********************************************************************************       
000019B2                          1062  Start_EOR_Disassembly
000019B2  45F9 00002B5C           1063          LEA EOR_op,A2
000019B8  4EB9 00002972           1064          JSR Start_String_Appending
000019BE  4EB9 000028D2           1065          JSR Place_D7_in_D3
000019C4  0243 01C0               1066          ANDI #$01C0,D3
000019C8  EC8B                    1067          LSR.L #6,D3
000019CA  0C43 0004               1068          CMPI #4,D3
000019CE  6700 0016               1069          BEQ Byte_Size_EOR
000019D2  0C43 0005               1070          CMPI #5,D3
000019D6  6700 0018               1071          BEQ Word_Size_EOR
000019DA  0C43 0006               1072          CMPI #6,D3
000019DE  6700 001A               1073          BEQ Long_Size_EOR
000019E2  6000 004C               1074          BRA EOR_Error
000019E6                          1075  Byte_Size_EOR
000019E6  4EB9 00002948           1076          JSR Byte_Print
000019EC  6000 0012               1077          BRA After_Size_EOR
000019F0                          1078  Word_Size_EOR
000019F0  4EB9 00002956           1079          JSR Word_Print
000019F6  6000 0008               1080          BRA After_Size_EOR
000019FA                          1081  Long_Size_EOR
000019FA  4EB9 00002964           1082          JSR Long_Print
00001A00                          1083  After_Size_EOR
00001A00  343C 0001               1084          MOVE #1,D2     * move 1 to D2 to specify printing the "destination" register (reaaly printing the left most register specification (bits 9 through 11)
00001A04  4244                    1085          CLR D4
00001A06  4EB9 00002298           1086          JSR R_Destination
00001A0C  4EB9 000028FC           1087          JSR Add_Comma
00001A12  383C 01F4               1088          MOVE #500,D4
00001A16  3C3C 003C               1089          MOVE #60,D6
00001A1A  4282                    1090          CLR.L D2
00001A1C  4EB9 00002374           1091          JSR DestAddressingModeDetermine
00001A22  4246                    1092          CLR D6
00001A24  D8C0                    1093          ADD D0,A4
00001A26  4EB9 00002694           1094          JSR TrapTask13
00001A2C  6000 F5EE               1095          BRA start_Disassembly
00001A30                          1096  EOR_Error
00001A30  4EB9 00002A06           1097          JSR Error_Subroutine
00001A36  D8C0                    1098          ADDA D0,A4
00001A38  6000 F5E2               1099          BRA start_Disassembly
00001A3C                          1100  
00001A3C                          1101  
00001A3C                          1102  *********************************************************************************
00001A3C                          1103  * Method Name: Start_Bcc_Disassembly
00001A3C                          1104  * Description: Begins processing of the decoding of a Bcc instruction (any one of them). The specific subtype is determined first via
00001A3C                          1105  *              bit masking. Appropriate ascii chars will then be put into the string buffer, call the "DestAddressingModeDetermine" 
00001A3C                          1106  *              function to determine the effective addresses, and print the appropriate string represented assembly language Bcc instruction.
00001A3C                          1107  *
00001A3C                          1108  * Calling Convention: Callee-Saved
00001A3C                          1109  *
00001A3C                          1110  * Preconditions & Method Input:
00001A3C                          1111  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001A3C                          1112  *
00001A3C                          1113  * Postconditions & Output:
00001A3C                          1114  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001A3C                          1115  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001A3C                          1116  *   necessary amount given current instruction format.
00001A3C                          1117  *
00001A3C                          1118  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "BVC,BLT,BCS,BGE")
00001A3C                          1119  *  A4 points to the current instruction opcode in memory
00001A3C                          1120  *  A3 stores a flag to indicate the size of the operation (1: byte, 2: word, 3: long) to the "DestAddressingModeDetermine" function (only has significance for handling
00001A3C                          1121  *  immediate addressing)
00001A3C                          1122  *  D7 holds the current instruction opcode word
00001A3C                          1123  *  D6 holds the word operands after the opcode word
00001A3C                          1124  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data, also stores width of ascii hex value to be appended
00001A3C                          1125  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001A3C                          1126  *  the function to know which addressing modes to forbid for this instruction.
00001A3C                          1127  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
00001A3C                          1128  *  D0 stores the amount by which A4 will be incremented after the completion of this function
00001A3C                          1129  *  D1 holds the hex value to be converted to hex
00001A3C                          1130  *********************************************************************************     
00001A3C                          1131  Start_Bcc_Disassembly
00001A3C  4EB9 000028D2           1132          JSR Place_D7_in_D3
00001A42  0283 00000F00           1133          ANDI.L #$0F00,D3
00001A48  3A3C 0008               1134          MOVE #8,D5
00001A4C  EAAB                    1135          LSR.L D5,D3
00001A4E                          1136  CheckCondition
00001A4E  0C43 0005               1137          CMPI #5,D3
00001A52  6700 0026               1138          BEQ BCS
00001A56  0C43 000C               1139          CMPI #12,D3
00001A5A  6700 002E               1140          BEQ BGE
00001A5E  0C43 000D               1141          CMPI #13,D3
00001A62  6700 0036               1142          BEQ BLT
00001A66  0C43 0008               1143          CMPI #8,D3
00001A6A  6700 003E               1144          BEQ BVC
00001A6E  0C43 0000               1145          CMPI #0,D3
00001A72  6700 0046               1146          BEQ BRA
00001A76  6000 00E4               1147          BRA UnrecognizedCondition
00001A7A                          1148  BCS
00001A7A  45F9 00002B2B           1149          LEA BCS_op,A2
00001A80  4EB9 00002972           1150          JSR Start_String_Appending
00001A86  6000 003E               1151          BRA Process_Bcc_Disassembly
00001A8A                          1152  BGE
00001A8A  45F9 00002B2F           1153          LEA BGE_op,A2
00001A90  4EB9 00002972           1154          JSR Start_String_Appending
00001A96  6000 002E               1155          BRA Process_Bcc_Disassembly
00001A9A                          1156  BLT
00001A9A  45F9 00002B33           1157          LEA BLT_op,A2
00001AA0  4EB9 00002972           1158          JSR Start_String_Appending
00001AA6  6000 001E               1159          BRA Process_Bcc_Disassembly
00001AAA                          1160  BVC
00001AAA  45F9 00002B37           1161          LEA BVC_op,A2
00001AB0  4EB9 00002972           1162          JSR Start_String_Appending
00001AB6  6000 000E               1163          BRA Process_Bcc_Disassembly
00001ABA                          1164          
00001ABA                          1165  BRA
00001ABA  45F9 00002B27           1166          LEA BRA_op,A2
00001AC0  4EB9 00002972           1167          JSR Start_String_Appending
00001AC6                          1168  
00001AC6                          1169  Process_Bcc_Disassembly
00001AC6  4EB9 000028D2           1170          JSR Place_D7_in_D3
00001ACC  0243 00FF               1171          ANDI #$00FF,D3
00001AD0  0C03 0000               1172          CMPI.B #$00,D3
00001AD4  6700 0042               1173          BEQ One_Word
00001AD8  0C03 00FF               1174          CMPI.B #$FF,D3
00001ADC  6700 007E               1175          BEQ UnrecognizedCondition
00001AE0  6000 0002               1176          BRA One_Byte
00001AE4                          1177  One_Byte
00001AE4  45F9 00002B8B           1178          LEA Byte_Size,A2
00001AEA  4EB9 00002972           1179          JSR Start_String_Appending
00001AF0  4EB9 000027AA           1180          JSR AddHexCash
00001AF6  4EB9 000028D2           1181          JSR Place_D7_in_D3
00001AFC  0243 00FF               1182          ANDI #$00FF,D3
00001B00  4281                    1183          CLR.L D1
00001B02  220C                    1184          MOVE.L A4,D1
00001B04  2803                    1185          MOVE.L D3,D4
00001B06  D284                    1186          ADD.L D4,D1
00001B08  5441                    1187          ADD #2,D1
00001B0A  363C 001C               1188          MOVE #28,D3
00001B0E  4EB9 000029BC           1189          JSR Add_Hex_String_To_Buffer
00001B14  6000 003A               1190          BRA After_Word_Decision
00001B18                          1191  One_Word
00001B18  45F9 00002B87           1192          LEA Word_Size,A2
00001B1E  4EB9 00002972           1193          JSR Start_String_Appending
00001B24  4EB9 000027AA           1194          JSR AddHexCash
00001B2A  267C 00000002           1195          MOVEA.L #2,A3           * Need to isolate A3 (2: word, 3: long)
00001B30  340C                    1196          MOVE A4, D2
00001B32  4EB9 00002856           1197          JSR IsolateInstrOperands
00001B38  4281                    1198          CLR.L D1
00001B3A  3206                    1199          MOVE.W D6,D1
00001B3C  D28C                    1200          ADD.L A4,D1
00001B3E  5441                    1201          ADD #2,D1
00001B40  363C 001C               1202          MOVE #28,D3
00001B44  0281 0000FFFF           1203          ANDI.L #$FFFF,D1
00001B4A  4EB9 000029BC           1204          JSR Add_Hex_String_To_Buffer
00001B50                          1205  After_Word_Decision 
00001B50  D8C0                    1206          ADDA D0,A4
00001B52  4EB9 00002694           1207          JSR TrapTask13
00001B58  6000 F4C2               1208          BRA start_Disassembly
00001B5C                          1209          
00001B5C                          1210  UnrecognizedCondition
00001B5C  4EB9 00002A06           1211          JSR Error_Subroutine
00001B62  D8C0                    1212          ADD D0,A4
00001B64  6000 F4B6               1213          BRA start_Disassembly
00001B68                          1214  
00001B68                          1215  
00001B68                          1216  *********************************************************************************
00001B68                          1217  * Method Name: Start_NEG_Disassembly
00001B68                          1218  * Description: Begins processing of the decoding of a NEG instruction. Appropriate ascii chars will then be put into the string buffer, 
00001B68                          1219  *              call the "DestAddressingModeDetermine" function to determine the effective addresses, and print the appropriate string 
00001B68                          1220  *              represented assembly language NEG instruction.
00001B68                          1221  *
00001B68                          1222  * Calling Convention: Callee-Saved
00001B68                          1223  *
00001B68                          1224  * Preconditions & Method Input:
00001B68                          1225  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001B68                          1226  *
00001B68                          1227  * Postconditions & Output:
00001B68                          1228  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001B68                          1229  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001B68                          1230  *   necessary amount given current instruction format.
00001B68                          1231  *
00001B68                          1232  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "NEG")
00001B68                          1233  *  A4 points to the current instruction opcode in memory
00001B68                          1234  *  D7 holds the current instruction opcode word
00001B68                          1235  *  D6 flag for destination operand for DestAdressingModeDetermine
00001B68                          1236  *  D3 temporarily holds a copy of the current intruction opcode word to allow for manipulation via bit masks, without loss of data, also stores width of ascii hex value to be appended
00001B68                          1237  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001B68                          1238  *  the function to know which addressing modes to forbid for this instruction.
00001B68                          1239  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
00001B68                          1240  *  D0 stores the amount by which A4 will be incremented after the completion of this function
00001B68                          1241  *********************************************************************************     
00001B68                          1242  Start_NEG_Disassembly
00001B68  45F9 00002B23           1243          LEA NEG_op,A2
00001B6E  4EB9 00002972           1244          JSR Start_String_Appending
00001B74  4EB9 000028D2           1245          JSR Place_D7_in_D3
00001B7A  0243 00C0               1246          ANDI #$00C0,D3
00001B7E  EC8B                    1247          LSR.L #6,D3
00001B80  0C43 0000               1248          CMPI #0,D3
00001B84  6700 0016               1249          BEQ NEG_Byte
00001B88  0C43 0001               1250          CMPI #1,D3
00001B8C  6700 001C               1251          BEQ NEG_Word
00001B90  0C43 0002               1252          CMPI #2,D3
00001B94  6700 0022               1253          BEQ NEG_Long
00001B98  6000 0046               1254          BRA NEG_Error
00001B9C                          1255  NEG_Byte
00001B9C  4EB9 00002948           1256          JSR Byte_Print
00001BA2  363C 0004               1257          MOVE #4,D3
00001BA6  6000 001A               1258          BRA NEG_Size_Determined
00001BAA                          1259  NEG_Word
00001BAA  4EB9 00002956           1260          JSR Word_Print
00001BB0  363C 000C               1261          MOVE #12,D3
00001BB4  6000 000C               1262          BRA NEG_Size_Determined
00001BB8                          1263  NEG_Long
00001BB8  4EB9 00002964           1264          JSR Long_Print
00001BBE  363C 001C               1265          MOVE #28,D3
00001BC2                          1266  NEG_Size_Determined
00001BC2  383C 01F4               1267          MOVE #500,D4     * flag for telling DestAddressingModeDetermine that a NEG operation called it
00001BC6  3C38 0060               1268          MOVE $60,D6
00001BCA  4242                    1269          CLR D2
00001BCC  4EB9 00002374           1270          JSR DestAddressingModeDetermine
00001BD2  4246                    1271          CLR D6
00001BD4  D8C0                    1272          ADDA D0,A4
00001BD6  4EB9 00002694           1273          JSR TrapTask13
00001BDC  6000 F43E               1274          BRA start_Disassembly
00001BE0                          1275  NEG_Error
00001BE0  4EB9 00002A06           1276          JSR Error_Subroutine
00001BE6  D8C0                    1277          ADDA D0,A4
00001BE8  6000 F432               1278          BRA start_Disassembly       
00001BEC                          1279  
00001BEC                          1280  
00001BEC                          1281  *********************************************************************************
00001BEC                          1282  * Method Name: Start_LEA_Disassembly
00001BEC                          1283  * Description: Begins processing of the decoding of a LEA instruction. Appropriate ascii chars will then be put into the string buffer, 
00001BEC                          1284  *              call the "DestAddressingModeDetermine" function to determine the effective addresses, and print the appropriate string 
00001BEC                          1285  *              represented assembly language LEA instruction.
00001BEC                          1286  *
00001BEC                          1287  * Calling Convention: Callee-Saved
00001BEC                          1288  *
00001BEC                          1289  * Preconditions & Method Input:
00001BEC                          1290  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001BEC                          1291  *
00001BEC                          1292  * Postconditions & Output:
00001BEC                          1293  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001BEC                          1294  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001BEC                          1295  *   necessary amount given current instruction format.
00001BEC                          1296  *
00001BEC                          1297  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "LEA")
00001BEC                          1298  *  A4 points to the current instruction opcode in memory
00001BEC                          1299  *  D6 flags a destination operand to "DestAddressingModeDetermine"
00001BEC                          1300  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001BEC                          1301  *  the function to know which addressing modes to forbid for this instruction.
00001BEC                          1302  *  D2 stores a flag that tells the effective addressing function, "DestAddressingModeDetermine" whether to process bits 0-5 (D2 = 1) or 6-11 (D2 = anything else)
00001BEC                          1303  *  D0 stores the amount by which A4 will be incremented after the completion of this function
00001BEC                          1304  *********************************************************************************     
00001BEC                          1305  Start_LEA_Disassembly
00001BEC  45F9 00002B1C           1306          LEA LEA_op,A2
00001BF2  4EB9 00002972           1307          JSR Start_String_Appending
00001BF8  383C 0190               1308          MOVE #400,D4      * flag to let DestAddressingModeDetermine know this is an LEA function
00001BFC  3C3C 003C               1309          MOVE #60,D6
00001C00  4282                    1310          CLR.L D2
00001C02  4EB9 00002374           1311          JSR DestAddressingModeDetermine
00001C08  4246                    1312          CLR D6
00001C0A  4EB9 000028FC           1313          JSR Add_Comma
00001C10  383C 0001               1314          MOVE #1,D4
00001C14  343C 0001               1315          MOVE #1,D2
00001C18  4EB9 00002298           1316          JSR R_Destination
00001C1E  D8C0                    1317          ADDA D0,A4
00001C20  4EB9 00002694           1318          JSR TrapTask13
00001C26  6000 F3F4               1319          BRA start_Disassembly
00001C2A                          1320  
00001C2A                          1321  
00001C2A                          1322  *********************************************************************************
00001C2A                          1323  * Method Name: Start_JSR_Disassembly
00001C2A                          1324  * Description: Begins processing of the decoding of a JSR instruction. Appropriate ascii chars will then be put into the string buffer, 
00001C2A                          1325  *              call the "DestAddressingModeDetermine" function to determine the effective addresses, and print the appropriate string 
00001C2A                          1326  *              represented assembly language JSR instruction.
00001C2A                          1327  *
00001C2A                          1328  * Calling Convention: Callee-Saved
00001C2A                          1329  *
00001C2A                          1330  * Preconditions & Method Input:
00001C2A                          1331  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001C2A                          1332  *
00001C2A                          1333  * Postconditions & Output:
00001C2A                          1334  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001C2A                          1335  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001C2A                          1336  *   necessary amount given current instruction format.
00001C2A                          1337  *
00001C2A                          1338  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "JSR")
00001C2A                          1339  *  A4 points to the current instruction opcode in memory
00001C2A                          1340  *  D6 flags a destination operand to "DestAddressingModeDetermine"
00001C2A                          1341  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001C2A                          1342  *  the function to know which addressing modes to forbid for this instruction.
00001C2A                          1343  *  D0 stores the amount by which A4 will be incremented after the completion of this function
00001C2A                          1344  *********************************************************************************  
00001C2A                          1345  Start_JSR_Disassembly
00001C2A  383C 0037               1346          MOVE #55,D4       * flag to let DestAddressingModeDetermine know this is a JSR instruction
00001C2E  3C3C 003C               1347          MOVE #60,D6
00001C32  45F9 00002B17           1348          LEA JSR_op,A2
00001C38  4EB9 00002972           1349          JSR Start_String_Appending
00001C3E  4EB9 00002374           1350          JSR DestAddressingModeDetermine
00001C44  4246                    1351          CLR D6
00001C46  D8C0                    1352          ADDA D0,A4
00001C48  4EB9 00002694           1353          JSR TrapTask13
00001C4E  6000 F3CC               1354          BRA start_Disassembly
00001C52                          1355  
00001C52                          1356  
00001C52                          1357  *********************************************************************************
00001C52                          1358  * Method Name: Start_Test_Bit_Clear_Disassembly1
00001C52                          1359  * Description: Begins processing of the decoding of a BCLR dynamic instruction. Source is always data register. Appropriate ascii chars 
00001C52                          1360  *              will then be put into the string buffer, call the "DestAddressingModeDetermine" function to determine the effective 
00001C52                          1361  *              addresses, and print the appropriate string represented assembly language BCLR instruction.
00001C52                          1362  *
00001C52                          1363  * Calling Convention: Callee-Saved
00001C52                          1364  *
00001C52                          1365  * Preconditions & Method Input:
00001C52                          1366  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001C52                          1367  *
00001C52                          1368  * Postconditions & Output:
00001C52                          1369  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001C52                          1370  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001C52                          1371  *   necessary amount given current instruction format.
00001C52                          1372  *
00001C52                          1373  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "BCLR")
00001C52                          1374  *  A4 points to the current instruction opcode in memory
00001C52                          1375  *  D6 flags a destination operand to "DestAddressingModeDetermine"
00001C52                          1376  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001C52                          1377  *  the function to know which addressing modes to forbid for this instruction.
00001C52                          1378  *********************************************************************************  
Line 1379 WARNING: Label too long
00001C52                          1379  Start_Test_Bit_Clear_Disassembly1 * make D4 1 if using an Address register
00001C52  45F9 00002B12           1380          LEA BCLR_op,A2
00001C58  4EB9 00002972           1381          JSR Start_String_Appending
00001C5E  3C3C 003C               1382          MOVE #60,D6 * marks a destination address for DestAddressingModeDetermine
00001C62  383C 000F               1383          MOVE #15,D4 * marks a destination location as from BCLR
00001C66  4EB9 00002374           1384          JSR DestAddressingModeDetermine
00001C6C  4246                    1385          CLR D6
00001C6E  D8C0                    1386          ADDA D0,A4
00001C70  4EB9 00002694           1387          JSR TrapTask13
00001C76  6000 F3A4               1388          BRA start_Disassembly
00001C7A                          1389  
00001C7A                          1390  
00001C7A                          1391  *********************************************************************************
00001C7A                          1392  * Method Name: Start_Test_Bit_Clear_Disassembly2
00001C7A                          1393  * Description: Begins processing of the decoding of a BCLR static instruction. Source is always immediate. Appropriate ascii chars 
00001C7A                          1394  *              will then be put into the string buffer, call the "DestAddressingModeDetermine" function to determine the effective 
00001C7A                          1395  *              addresses, and print the appropriate string represented assembly language BCLR instruction.
00001C7A                          1396  *
00001C7A                          1397  * Calling Convention: Callee-Saved
00001C7A                          1398  *
00001C7A                          1399  * Preconditions & Method Input:
00001C7A                          1400  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001C7A                          1401  *
00001C7A                          1402  * Postconditions & Output:
00001C7A                          1403  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001C7A                          1404  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001C7A                          1405  *   necessary amount given current instruction format.
00001C7A                          1406  *
00001C7A                          1407  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "BCLR")
00001C7A                          1408  *  A3 holds immediate data after opcode word
00001C7A                          1409  *  A4 points to the current instruction opcode in memory
00001C7A                          1410  *  D3 used for both specifying width size of converted hex to ascii character, and acts as a bit mask destination for isolating bits for operation size validation
00001C7A                          1411  *  D6 flags a destination operand to "DestAddressingModeDetermine"
00001C7A                          1412  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001C7A                          1413  *  the function to know which addressing modes to forbid for this instruction.
00001C7A                          1414  *  D1 holds the immediate data (transferred from D6 to fulfill AsciiToHex precondition of value in D1)
00001C7A                          1415  *********************************************************************************  
Line 1416 WARNING: Label too long
00001C7A                          1416  Start_Test_Bit_Clear_Disassembly2
00001C7A  45F9 00002B12           1417          LEA BCLR_op,A2
00001C80  4EB9 00002972           1418          JSR Start_String_Appending
00001C86  366C 0002               1419          MOVE (2,A4),A3
00001C8A  5440                    1420          ADD #2,D0
00001C8C  320B                    1421          MOVE A3,D1
00001C8E  0C81 000000FF           1422          CMPI.L #255,D1
00001C94  6E00 0028               1423          BGT BCLR_ERROR
00001C98  3607                    1424          MOVE D7,D3
00001C9A  0283 00000038           1425          ANDI.L #$0038,D3
00001CA0  E68B                    1426          LSR.L #3,D3
00001CA2  0C43 0000               1427          CMPI #0,D3
00001CA6  6700 0022               1428          BEQ WriteLong
00001CAA                          1429  WriteByte
00001CAA  45F9 00002B8B           1430          LEA Byte_Size,A2
00001CB0  4EB9 00002972           1431          JSR Start_String_Appending   
00001CB6  363C 0004               1432          MOVE #4,D3   
00001CBA  6000 001E               1433          BRA After_Size_Decision
00001CBE                          1434  BCLR_ERROR
00001CBE  4EB9 00002A06           1435          JSR Error_Subroutine
00001CC4  D8C0                    1436          ADDA D0,A4
00001CC6  6000 0042               1437          BRA END_BCLR
00001CCA                          1438  WriteLong
00001CCA  45F9 00002B8F           1439          LEA Long_Size,A2
00001CD0  363C 001C               1440          MOVE #28,D3
00001CD4  4EB9 00002972           1441          JSR Start_String_Appending
00001CDA                          1442  After_Size_Decision
00001CDA  383C 0032               1443          MOVE #50,D4
00001CDE  3C3C 003C               1444          MOVE #60,D6
00001CE2  4EB9 000027B8           1445          JSR AddPoundSign
00001CE8  4EB9 000027AA           1446          JSR AddHexCash
00001CEE  4EB9 000029BC           1447          JSR Add_Hex_String_To_Buffer
00001CF4  4EB9 000028FC           1448          JSR Add_Comma
00001CFA  4EB9 00002374           1449          JSR DestAddressingModeDetermine
00001D00  4246                    1450          CLR D6
00001D02  D8C0                    1451          ADDA D0,A4
00001D04                          1452          *ADDA #2,A4
00001D04  4EB9 00002694           1453          JSR TrapTask13
00001D0A                          1454  END_BCLR
00001D0A  6000 F310               1455          BRA start_Disassembly
00001D0E                          1456          
00001D0E                          1457  
00001D0E                          1458  *********************************************************************************
00001D0E                          1459  * Method Name: BCLR_Data_Register_Print
00001D0E                          1460  * Description: Adds to the string buffer a data register of number matching what is specified in bits 9-11.
00001D0E                          1461  *
00001D0E                          1462  * Calling Convention: Caller-Saved
00001D0E                          1463  *
00001D0E                          1464  * Preconditions & Method Input:
00001D0E                          1465  *   Called by a function in the middle of processing a BCLR instruction. A4 references the current instruction opcode word, as well as D7.
00001D0E                          1466  *
00001D0E                          1467  * Postconditions & Output:
00001D0E                          1468  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Print_Data_Register" and "Add_Hex_String_To_Buffer" call.
00001D0E                          1469  *
00001D0E                          1470  *  D7 holds the current opcode intruction word
00001D0E                          1471  *  D3 holds a copy of the current opcode instruction word for processing bit masks and manipulating data without permanent loss
00001D0E                          1472  *  D5 holds a shift count for shifting register D3 (since shift value is greater than 8)
00001D0E                          1473  *  D1 holds the register number for the data register, and is converted from hex to ascii to add to the buffer
00001D0E                          1474  *********************************************************************************  
00001D0E                          1475  BCLR_Regs REG D0-D3,D5
00001D0E                          1476  BCLR_Data_Register_Print
00001D0E  48E7 F000               1477          MOVEM.L BCLR_Regs,-(SP)
00001D12  4EB9 000028B6           1478          JSR Print_Data_Register
00001D18  2607                    1479          MOVE.L D7,D3
00001D1A  0283 00000E00           1480          ANDI.L #$0E00,D3
00001D20  3A3C 0009               1481          MOVE #9,D5
00001D24  EAAB                    1482          LSR.L D5,D3
00001D26  3203                    1483          MOVE D3,D1
00001D28  363C 0000               1484          MOVE #0,D3
00001D2C  4EB9 000029BC           1485          JSR Add_Hex_String_To_Buffer
00001D32  4CDF 000F               1486          MOVEM.L (SP)+,BCLR_Regs
00001D36  4E75                    1487          RTS
00001D38                          1488  
00001D38                          1489  *********************************************************************************
00001D38                          1490  * Method Name: Start_MoveM_toM_Disassembly
00001D38                          1491  * Description: Begins processing of the decoding of a MOVEM dynamic instruction. Determines direction of transfer (either memory to register or register to
00001D38                          1492  *              memory). Appropriate ascii chars will then be put into the string buffer, call the "DestAddressingModeDetermine" function to determine the 
00001D38                          1493  *              effective addresses, and print the appropriate string represented assembly language MOVEM instruction.
00001D38                          1494  *
00001D38                          1495  * Calling Convention: Callee-Saved
00001D38                          1496  *
00001D38                          1497  * Preconditions & Method Input:
00001D38                          1498  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
00001D38                          1499  *
00001D38                          1500  * Postconditions & Output:
00001D38                          1501  *   Appends to string buffer the correct assembly language equivalent to opcode word via "Start_String_Appending" call, prints 
00001D38                          1502  *   the string to console and writes to file via "TrapTask13" call. Clears the buffer after it's done using it. Increment the A4 instruction pointer
00001D38                          1503  *   necessary amount given current instruction format.
00001D38                          1504  *
00001D38                          1505  *  A2 holds the address of the variable string holding the operation string opcode word (i.e. "MOVEM")
00001D38                          1506  *  A3 stores the register list before moving it to D6
00001D38                          1507  *  A4 points to the current instruction opcode in memory
00001D38                          1508  *  D7 holds the current intruction opcode word
00001D38                          1509  *  D3 holds a copy of the current intruction opcode word for the purposes of bit mask manipulation without permanently losing data from D7
00001D38                          1510  *  D6 holds the register list that comes after the instruction opcode word
00001D38                          1511  *  D4 stores a flag that uniquely identifies this function as the calling function when "DestAddressingModeDetermine" is called, allowing
00001D38                          1512  *  the function to know which addressing modes to forbid for this instruction.
00001D38                          1513  *  D5 holds the shift value for registers to shift by (when shift value is greater than 8)
00001D38                          1514  *  D2 stores a flag that indicates which bits to isolate for an effective address in a function call (0: bits 0-5, 1: 6-11)
00001D38                          1515  *********************************************************************************  
00001D38                          1516  Start_MoveM_toM_Disassembly
00001D38  45F9 00002B04           1517          LEA MoveM_op,A2
00001D3E  4EB9 00002972           1518          JSR Start_String_Appending
00001D44  366C 0002               1519          MOVE (2, A4),A3
00001D48  3607                    1520          MOVE D7,D3
00001D4A  0243 0040               1521          ANDI.W #$0040,D3
00001D4E  EC4B                    1522          LSR #6,D3
00001D50  6700 000C               1523          BEQ Print_Word       
00001D54                          1524  Print_Long
00001D54  45F9 00002B8F           1525          LEA Long_Size,A2
00001D5A  6000 0008               1526          BRA M_Size_Decided
00001D5E                          1527  
00001D5E                          1528  Print_Word
00001D5E  45F9 00002B87           1529          LEA Word_Size,A2
00001D64                          1530          
00001D64                          1531  M_Size_Decided
00001D64  4EB9 00002972           1532          JSR Start_String_Appending
00001D6A                          1533          *ADDA #2,A4
00001D6A  4282                    1534          CLR.L D2
00001D6C  4EB9 000028D2           1535          JSR Place_D7_in_D3
00001D72  0243 0400               1536          ANDI.W #$0400,D3
00001D76  3A3C 000A               1537          MOVE #10,D5
00001D7A  EAAB                    1538          LSR.L D5,D3
00001D7C  0C43 0001               1539          CMPI #1,D3
00001D80  6700 0016               1540          BEQ Mem_to_Reg
00001D84  0C43 0000               1541          CMPI #0,D3
00001D88  6700 0038               1542          BEQ Reg_to_Mem
00001D8C  4EB9 00002A06           1543          JSR Error_Subroutine
00001D92  D8C0                    1544          ADD D0,A4
00001D94  6000 F286               1545          BRA start_Disassembly
00001D98                          1546          
00001D98                          1547  Mem_to_Reg
00001D98  383C 0041               1548          MOVE #65,D4
00001D9C  4EB9 00002374           1549          JSR DestAddressingModeDetermine
00001DA2  4EB9 000028FC           1550          JSR Add_Comma
00001DA8  4EB9 00001DEC           1551          JSR GetRegisterList
00001DAE  4EB9 000028D6           1552          JSR Increment_Function
00001DB4  4283                    1553          CLR.L D3
00001DB6  D8C0                    1554          ADD D0,A4
00001DB8  4EB9 00002694           1555          JSR TrapTask13
00001DBE  6000 F25C               1556          BRA start_Disassembly
00001DC2                          1557  
00001DC2                          1558  Reg_to_Mem
00001DC2  4EB9 00001DEC           1559          JSR GetRegisterList
00001DC8  4EB9 000028FC           1560          JSR Add_Comma
00001DCE  383C 0042               1561          MOVE #66,D4
00001DD2  4EB9 00002374           1562          JSR DestAddressingModeDetermine * will determine effective address
00001DD8  4EB9 000028D6           1563          JSR Increment_Function
00001DDE  4283                    1564          CLR.L D3
00001DE0  D8C0                    1565          ADD D0,A4
00001DE2  4EB9 00002694           1566          JSR TrapTask13
00001DE8  6000 F232               1567          BRA start_Disassembly
00001DEC                          1568  
00001DEC                          1569  
00001DEC                          1570  GetRegisterList:
00001DEC  3C07                    1571          MOVE D7,D6
00001DEE  0246 0038               1572          ANDI #Move_Source_Mode,D6
00001DF2  E68E                    1573          LSR.L #3,D6
00001DF4  0C46 0004               1574          CMPI #4,D6
00001DF8  6700 0006               1575          BEQ Set_Flag
00001DFC  6000 0006               1576          BRA After_Flag_Decision
00001E00  383C 0064               1577  Set_Flag MOVE #100,D4 * tells the algorithm that the mode used is predecrement
00001E04                          1578  After_Flag_Decision
00001E04  3C4B                    1579          MOVEA A3,A6
00001E06                          1580          *ADDA #2,A6
00001E06  3C0E                    1581          MOVE A6,D6
00001E08  3606                    1582          MOVE D6,D3
00001E0A  0243 0001               1583          ANDI #$0001,D3 * get least significant bit (equivalent to D0)
00001E0E  3A3C 0000               1584          MOVE #0,D5
00001E12  EAAB                    1585          LSR.L D5,D3
00001E14  0C43 0001               1586          CMPI #1,D3
00001E18  6700 0006               1587          BEQ Mark1
00001E1C  6000 0020               1588  NotMet1 BRA NextPoint1   
00001E20                          1589  Mark1   
00001E20  0C44 0064               1590          CMPI #100,D4
00001E24  6700 0012               1591          BEQ PreDecrementMode
00001E28  4EB9 000021AE           1592          JSR CallDPrintNumber
00001E2E  4EB9 00002918           1593          JSR Add_Slash
00001E34  6000 0008               1594          BRA NextPoint1
00001E38  4EB9 000028DA           1595  PreDecrementMode JSR MOVEM_PreDecrement
00001E3E                          1596  NextPoint1
00001E3E  3C0E                    1597          MOVE A6,D6
00001E40  3606                    1598          MOVE D6,D3
00001E42  0243 0002               1599          ANDI #$0002,D3
00001E46  3A3C 0001               1600          MOVE #1,D5
00001E4A  EAAB                    1601          LSR.L D5,D3
00001E4C  0C43 0001               1602          CMPI #1,D3
00001E50  6700 0006               1603          BEQ Mark2
00001E54  6000 0020               1604  NotMet2 BRA NextPoint2        
00001E58                          1605  Mark2   
00001E58  0C44 0064               1606          CMPI #100,D4
00001E5C  6700 0012               1607          BEQ PreDecrementMode2
00001E60  4EB9 000021AE           1608          JSR CallDPrintNumber
00001E66  4EB9 00002918           1609          JSR Add_Slash
00001E6C  6000 0008               1610          BRA NextPoint2
00001E70  4EB9 000028DA           1611  PreDecrementMode2 JSR MOVEM_PreDecrement
00001E76                          1612  NextPoint2
00001E76  3C0E                    1613          MOVE A6,D6
00001E78  3606                    1614          MOVE D6,D3
00001E7A  0243 0004               1615          ANDI #$0004,D3
00001E7E  3A3C 0002               1616          MOVE #2,D5
00001E82  EAAB                    1617          LSR.L D5,D3
00001E84  0C43 0001               1618          CMPI #1,D3
00001E88  6700 0006               1619          BEQ Mark3
00001E8C  6000 0020               1620  NotMet3 BRA NextPoint3
00001E90                          1621  Mark3   
00001E90  0C44 0064               1622          CMPI #100,D4
00001E94  6700 0012               1623          BEQ PreDecrementMode3
00001E98  4EB9 000021AE           1624          JSR CallDPrintNumber
00001E9E  4EB9 00002918           1625          JSR Add_Slash
00001EA4  6000 0008               1626          BRA NextPoint3
00001EA8  4EB9 000028DA           1627  PreDecrementMode3 JSR MOVEM_PreDecrement
00001EAE                          1628  NextPoint3
00001EAE  3C0E                    1629          MOVE A6,D6
00001EB0  3606                    1630          MOVE D6,D3
00001EB2  0243 0008               1631          ANDI #$0008,D3
00001EB6  3A3C 0003               1632          MOVE #3,D5
00001EBA  EAAB                    1633          LSR.L D5,D3
00001EBC  0C43 0001               1634          CMPI #1,D3
00001EC0  6700 0006               1635          BEQ Mark4
00001EC4  6000 0020               1636  NotMet4 BRA NextPoint4
00001EC8                          1637  Mark4   
00001EC8  0C44 0064               1638          CMPI #100,D4
00001ECC  6700 0012               1639          BEQ PreDecrementMode4
00001ED0  4EB9 000021AE           1640          JSR CallDPrintNumber
00001ED6  4EB9 00002918           1641          JSR Add_Slash
00001EDC  6000 0008               1642          BRA NextPoint4
00001EE0  4EB9 000028DA           1643  PreDecrementMode4 JSR MOVEM_PreDecrement
00001EE6                          1644  NextPoint4
00001EE6  3C0E                    1645          MOVE A6,D6
00001EE8  3606                    1646          MOVE D6,D3
00001EEA  0243 0010               1647          ANDI #$0010,D3
00001EEE  3A3C 0004               1648          MOVE #4,D5
00001EF2  EAAB                    1649          LSR.L D5,D3
00001EF4  0C43 0001               1650          CMPI #1,D3
00001EF8  6700 0006               1651          BEQ Mark5                       
00001EFC  6000 0020               1652  NotMet5 BRA NextPoint5
00001F00                          1653  Mark5   
00001F00  0C44 0064               1654          CMPI #100,D4
00001F04  6700 0012               1655          BEQ PreDecrementMode5
00001F08  4EB9 000021AE           1656          JSR CallDPrintNumber
00001F0E  4EB9 00002918           1657          JSR Add_Slash
00001F14  6000 0008               1658          BRA NextPoint5
00001F18  4EB9 000028DA           1659  PreDecrementMode5 JSR MOVEM_PreDecrement
00001F1E                          1660  NextPoint5
00001F1E  3C0E                    1661          MOVE A6,D6
00001F20  3606                    1662          MOVE D6,D3
00001F22  0243 0020               1663          ANDI #$0020,D3
00001F26  3A3C 0005               1664          MOVE #5,D5
00001F2A  EAAB                    1665          LSR.L D5,D3
00001F2C  0C43 0001               1666          CMPI #1,D3
00001F30  6700 0006               1667          BEQ Mark6      
00001F34  6000 0020               1668  NotMet6 BRA NextPoint6
00001F38                          1669  Mark6   
00001F38  0C44 0064               1670          CMPI #100,D4
00001F3C  6700 0012               1671          BEQ PreDecrementMode6
00001F40  4EB9 000021AE           1672          JSR CallDPrintNumber
00001F46  4EB9 00002918           1673          JSR Add_Slash
00001F4C  6000 0008               1674          BRA NextPoint6
00001F50  4EB9 000028DA           1675  PreDecrementMode6 JSR MOVEM_PreDecrement
00001F56                          1676  NextPoint6
00001F56  3C0E                    1677          MOVE A6,D6
00001F58  3606                    1678          MOVE D6,D3
00001F5A  0243 0040               1679          ANDI #$0040,D3
00001F5E  3A3C 0006               1680          MOVE #6,D5
00001F62  EAAB                    1681          LSR.L D5,D3
00001F64  0C43 0001               1682          CMPI #1,D3
00001F68  6700 0006               1683          BEQ Mark7
00001F6C  6000 0020               1684  NotMet7 BRA NextPoint7
00001F70                          1685  Mark7   
00001F70  0C44 0064               1686          CMPI #100,D4
00001F74  6700 0012               1687          BEQ PreDecrementMode7
00001F78  4EB9 000021AE           1688          JSR CallDPrintNumber
00001F7E  4EB9 00002918           1689          JSR Add_Slash
00001F84  6000 0008               1690          BRA NextPoint7
00001F88  4EB9 000028DA           1691  PreDecrementMode7 JSR MOVEM_PreDecrement
00001F8E                          1692  NextPoint7
00001F8E  3C0E                    1693          MOVE A6,D6
00001F90  3606                    1694          MOVE D6,D3
00001F92  0243 0080               1695          ANDI #$0080,D3
00001F96  3A3C 0007               1696          MOVE #7,D5
00001F9A  EAAB                    1697          LSR.L D5,D3
00001F9C  0C43 0001               1698          CMPI #1,D3
00001FA0  6700 0006               1699          BEQ Mark8
00001FA4  6000 0020               1700  NotMet8 BRA NextPoint8
00001FA8                          1701  Mark8   
00001FA8  0C44 0064               1702          CMPI #100,D4
00001FAC  6700 0012               1703          BEQ PreDecrementMode8
00001FB0  4EB9 000021AE           1704          JSR CallDPrintNumber
00001FB6  4EB9 00002918           1705          JSR Add_Slash
00001FBC  6000 0008               1706          BRA NextPoint8
00001FC0  4EB9 000028DA           1707  PreDecrementMode8 JSR MOVEM_PreDecrement
00001FC6                          1708  NextPoint8
00001FC6  3C0E                    1709          MOVE A6,D6
00001FC8  3606                    1710          MOVE D6,D3
00001FCA  0243 0100               1711          ANDI #$0100,D3
00001FCE  3A3C 0008               1712          MOVE #8,D5
00001FD2  EAAB                    1713          LSR.L D5,D3
00001FD4  0C43 0001               1714          CMPI #1,D3
00001FD8  6700 0006               1715          BEQ Mark9
00001FDC  6000 0026               1716  NotMet9 BRA NextPoint9
00001FE0                          1717  Mark9   
00001FE0  0C44 0064               1718          CMPI #100,D4
00001FE4  6700 0014               1719          BEQ PreDecrementMode9
00001FE8  5145                    1720          SUBI #8,D5
00001FEA  4EB9 000021C8           1721          JSR CallAPrintNumber
00001FF0  4EB9 00002918           1722          JSR Add_Slash
00001FF6  6000 000C               1723          BRA NextPoint9
00001FFA                          1724  PreDecrementMode9 
00001FFA  343C 0001               1725          MOVE #1,D2
00001FFE  4EB9 000028EE           1726          JSR MOVEM_PreDecrement_Rev
00002004                          1727  NextPoint9
00002004  343C 0001               1728          MOVE #1,D2
00002008  3C0E                    1729          MOVE A6,D6
0000200A  3606                    1730          MOVE D6,D3
0000200C  0243 0200               1731          ANDI #$0200,D3
00002010  3A3C 0009               1732          MOVE #9,D5
00002014  EAAB                    1733          LSR.L D5,D3
00002016  5442                    1734          ADDI #2,D2
00002018  0C43 0001               1735          CMPI #1,D3
0000201C  6700 0006               1736          BEQ Mark10
00002020  6000 0022               1737  NotMet10 BRA NextPoint10
00002024                          1738  Mark10  
00002024  0C44 0064               1739          CMPI #100,D4
00002028  6700 0014               1740          BEQ PreDecrementMode10
0000202C  5145                    1741          SUBI #8,D5
0000202E  4EB9 000021C8           1742          JSR CallAPrintNumber
00002034  4EB9 00002918           1743          JSR Add_Slash
0000203A  6000 0008               1744          BRA NextPoint10
0000203E  4EB9 000028EE           1745  PreDecrementMode10 JSR MOVEM_PreDecrement_Rev
00002044                          1746  NextPoint10
00002044  3C0E                    1747          MOVE A6,D6
00002046  3606                    1748          MOVE D6,D3
00002048  0243 0400               1749          ANDI #$0400,D3
0000204C  3A3C 000A               1750          MOVE #10,D5
00002050  EAAB                    1751          LSR.L D5,D3
00002052  5442                    1752          ADDI #2,D2
00002054  0C43 0001               1753          CMPI #1,D3
00002058  6700 0006               1754          BEQ Mark11
0000205C  6000 0022               1755  NotMet11 BRA NextPoint11
00002060                          1756  Mark11  
00002060  0C44 0064               1757          CMPI #100,D4
00002064  6700 0014               1758          BEQ PreDecrementMode11
00002068  5145                    1759          SUBI #8,D5
0000206A  4EB9 000021C8           1760          JSR CallAPrintNumber
00002070  4EB9 00002918           1761          JSR Add_Slash
00002076  6000 0008               1762          BRA NextPoint11
0000207A  4EB9 000028EE           1763  PreDecrementMode11 JSR MOVEM_PreDecrement_Rev
00002080                          1764  NextPoint11
00002080  3C0E                    1765          MOVE A6,D6
00002082  3606                    1766          MOVE D6,D3
00002084  0243 0800               1767          ANDI #$0800,D3
00002088  3A3C 000B               1768          MOVE #11,D5
0000208C  EAAB                    1769          LSR.L D5,D3
0000208E  5442                    1770          ADDI #2,D2
00002090  0C43 0001               1771          CMPI #1,D3
00002094  6700 0006               1772          BEQ Mark12
00002098  6000 0022               1773  NotMet12 BRA NextPoint12
0000209C                          1774  Mark12  
0000209C  0C44 0064               1775          CMPI #100,D4
000020A0  6700 0014               1776          BEQ PreDecrementMode12
000020A4  5145                    1777          SUBI #8,D5
000020A6  4EB9 000021C8           1778          JSR CallAPrintNumber
000020AC  4EB9 00002918           1779          JSR Add_Slash
000020B2  6000 0008               1780          BRA NextPoint12
000020B6  4EB9 000028EE           1781  PreDecrementMode12 JSR MOVEM_PreDecrement_Rev
000020BC                          1782  NextPoint12
000020BC  3C0E                    1783          MOVE A6,D6
000020BE  3606                    1784          MOVE D6,D3
000020C0  0243 1000               1785          ANDI #$1000,D3
000020C4  3A3C 000C               1786          MOVE #12,D5
000020C8  EAAB                    1787          LSR.L D5,D3
000020CA  5442                    1788          ADDI #2,D2
000020CC  0C43 0001               1789          CMPI #1,D3
000020D0  6700 0006               1790          BEQ Mark13
000020D4  6000 0022               1791  NotMet13 BRA NextPoint13
000020D8                          1792  Mark13  
000020D8  0C44 0064               1793          CMPI #100,D4
000020DC  6700 0014               1794          BEQ PreDecrementMode13
000020E0  5145                    1795          SUBI #8,D5
000020E2  4EB9 000021C8           1796          JSR CallAPrintNumber
000020E8  4EB9 00002918           1797          JSR Add_Slash
000020EE  6000 0008               1798          BRA NextPoint13
000020F2  4EB9 000028EE           1799  PreDecrementMode13 JSR MOVEM_PreDecrement_Rev
000020F8                          1800  NextPoint13
000020F8  3C0E                    1801          MOVE A6,D6
000020FA  3606                    1802          MOVE D6,D3
000020FC  0243 2000               1803          ANDI #$2000,D3
00002100  3A3C 000D               1804          MOVE #13,D5
00002104  EAAB                    1805          LSR.L D5,D3
00002106  5442                    1806          ADDI #2,D2
00002108  0C43 0001               1807          CMPI #1,D3
0000210C  6700 0006               1808          BEQ Mark14
00002110  6000 0022               1809  NotMet14 BRA NextPoint14
00002114                          1810  Mark14  
00002114  0C44 0064               1811          CMPI #100,D4
00002118  6700 0014               1812          BEQ PreDecrementMode14
0000211C  5145                    1813          SUBI #8,D5
0000211E  4EB9 000021C8           1814          JSR CallAPrintNumber
00002124  4EB9 00002918           1815          JSR Add_Slash
0000212A  6000 0008               1816          BRA NextPoint14
0000212E  4EB9 000028EE           1817  PreDecrementMode14 JSR MOVEM_PreDecrement_Rev
00002134                          1818  NextPoint14
00002134  3C0E                    1819          MOVE A6,D6
00002136  3606                    1820          MOVE D6,D3
00002138  0243 4000               1821          ANDI #$4000,D3
0000213C  3A3C 000E               1822          MOVE #14,D5
00002140  EAAB                    1823          LSR.L D5,D3
00002142  5442                    1824          ADDI #2,D2
00002144  0C43 0001               1825          CMPI #1,D3
00002148  6700 0006               1826          BEQ Mark15
0000214C  6000 0022               1827  NotMet15 BRA NextPoint15
00002150                          1828  Mark15  
00002150  0C44 0064               1829          CMPI #100,D4
00002154  6700 0014               1830          BEQ PreDecrementMode15
00002158  5145                    1831          SUBI #8,D5
0000215A  4EB9 000021C8           1832          JSR CallAPrintNumber
00002160  4EB9 00002918           1833          JSR Add_Slash
00002166  6000 0008               1834          BRA NextPoint15
0000216A  4EB9 000028EE           1835  PreDecrementMode15 JSR MOVEM_PreDecrement_Rev
00002170                          1836  NextPoint15
00002170  3C0E                    1837          MOVE A6,D6
00002172  3606                    1838          MOVE D6,D3
00002174  0243 8000               1839          ANDI #$8000,D3
00002178  3A3C 000F               1840          MOVE #15,D5
0000217C  EAAB                    1841          LSR.L D5,D3
0000217E  5442                    1842          ADDI #2,D2
00002180  0C43 0001               1843          CMPI #1,D3
00002184  6700 0006               1844          BEQ Mark16
00002188  6000 0022               1845  NotMet16 BRA NextPoint16
0000218C                          1846  Mark16  
0000218C  0C44 0064               1847          CMPI #100,D4
00002190  6700 0014               1848          BEQ PreDecrementMode16
00002194  5145                    1849          SUBI #8,D5
00002196  4EB9 000021C8           1850          JSR CallAPrintNumber
0000219C  4EB9 00002918           1851          JSR Add_Slash
000021A2  6000 0008               1852          BRA NextPoint16
000021A6  4EB9 000028EE           1853  PreDecrementMode16 JSR MOVEM_PreDecrement_Rev
000021AC                          1854  NextPoint16
000021AC  4E75                    1855          RTS 
000021AE                          1856          
000021AE                          1857  
000021AE                          1858  *********************************************************************************
000021AE                          1859  * Method Name: CallDPrintNumber
000021AE                          1860  * Description: Loads the "D" prefix of a data register into the string buffer. As well as append the hex number in D1 in Ascii format. 
000021AE                          1861  *
000021AE                          1862  * Calling Convention: None
000021AE                          1863  *
000021AE                          1864  * Preconditions & Method Input:
000021AE                          1865  *   None
000021AE                          1866  *
000021AE                          1867  * Postconditions & Output:
000021AE                          1868  *   Appends to string buffer the ascii character "D" followed by the ascii converted hex value in D1.
000021AE                          1869  *
000021AE                          1870  *  A2 holds the address of the variable string holding the ascii char we want (i.e. "D")
000021AE                          1871  *  D3 holds the width of the ascii converted hex value to be appended to the string buffer
000021AE                          1872  *  D5 holds the value that will be moved to D1 to be converted from hex to ascii and appended to the buffer
000021AE                          1873  *  D1 holds the hex value that will be converted to ascii and appended to the string buffer
000021AE                          1874  *********************************************************************************  
000021AE                          1875  CallDPrintNumber
000021AE  45F9 00002B83           1876          LEA Data_Register,A2
000021B4  4EB9 00002972           1877          JSR Start_String_Appending
000021BA  3205                    1878          MOVE D5,D1
000021BC  363C 0000               1879          MOVE #0,D3
000021C0  4EB9 000029BC           1880          JSR Add_Hex_String_To_Buffer
000021C6  4E75                    1881          RTS
000021C8                          1882          
000021C8                          1883          
000021C8                          1884  *********************************************************************************
000021C8                          1885  * Method Name: CallAPrintNumber
000021C8                          1886  * Description: Loads the "A" prefix of a data register into the string buffer. As well as append the hex number in D1 in Ascii format. 
000021C8                          1887  *
000021C8                          1888  * Calling Convention: None
000021C8                          1889  *
000021C8                          1890  * Preconditions & Method Input:
000021C8                          1891  *   None
000021C8                          1892  *
000021C8                          1893  * Postconditions & Output:
000021C8                          1894  *   Appends to string buffer the ascii character "A" followed by the ascii converted hex value in D1.
000021C8                          1895  *
000021C8                          1896  *  A2 holds the address of the variable string holding the ascii char we want (i.e. "A")
000021C8                          1897  *  D3 holds the width of the ascii converted hex value to be appended to the string buffer
000021C8                          1898  *  D5 holds the value that will be moved to D1 to be converted from hex to ascii and appended to the buffer
000021C8                          1899  *  D1 holds the hex value that will be converted to ascii and appended to the string buffer
000021C8                          1900  ********************************************************************************* 
000021C8                          1901  CallAPrintNumber
000021C8  45F9 00002B85           1902          LEA Address_Register,A2
000021CE  4EB9 00002972           1903          JSR Start_String_Appending
000021D4  3205                    1904          MOVE D5,D1
000021D6  363C 0000               1905          MOVE #0,D3
000021DA  4EB9 000029BC           1906          JSR Add_Hex_String_To_Buffer
000021E0  4E75                    1907          RTS
000021E2                          1908  
000021E2                          1909  *********************************************************************************
000021E2                          1910  * Method Name: Start_Move_Disassembly
000021E2                          1911  * Description: Begins processing of the decoding of a standard MOVE instruction. Can branch to processing a MOVEA instruction disassembling label
000021E2                          1912  *              if condition for bits passes. Appropriate ascii chars will then be as into the string buffer, call the "DestAddressingModeDetermine" 
000021E2                          1913  *              function to determine the effective addresses, and print the appropriate string represented assembly language MOVE instruction, or MOVEA if
000021E2                          1914  *              determined.
000021E2                          1915  *
000021E2                          1916  * Calling Convention: Caller-Saved
000021E2                          1917  *
000021E2                          1918  * Preconditions & Method Input:
000021E2                          1919  *   Is called by the "start_Disassembly" function after correct opcode fields matching. A4 references the current instruction opcode word, as well as D7.
000021E2                          1920  *
000021E2                          1921  * Postconditions & Output:
000021E2                          1922  *   Appends to string buffer the correct assembly language equivalent to opcode word MOVE via "Start_String_Appending" and "TrapTask13" call.
000021E2                          1923  *
000021E2                          1924  *  A2 holds the address of the variable string holding the ascii char we want (i.e. "MOVE", or "MOVEA", or ".L ",".W ",".B ")
000021E2                          1925  *  A3 acts as a flag for DestAdressingModeDetermine for operation size (1: byte, 2: word, 3: long)
000021E2                          1926  *  D7 holds the current instruction opcode word
000021E2                          1927  *  D3 holds a copy of the current instruction opcode word for allowing bit mask manipulation without losing D7 data (helps for operation size determination)
000021E2                          1928  *  D5 holds the shift value that is used to shift values in data register with shift count greater than 8
000021E2                          1929  *  D2 stores a flag that tells "DestAddressingModeDetermine" which effective address bits to process (1: 0-5 bits, 2: 6-11 bits)
000021E2                          1930  ********************************************************************************* 
000021E2                          1931  Start_Move_Disassembly
000021E2  4EB9 000021F4           1932          JSR Move_operation   * If D3 is greater than or equal to 0, start the "MOVE" dissassembling
000021E8  D8C0                    1933          ADDA D0,A4
000021EA  4EB9 00002694           1934          JSR TrapTask13
000021F0  6000 EE2A               1935          BRA start_Disassembly
000021F4                          1936  
000021F4                          1937  Move_Registers REG D3,D2,A1 * set of register to be saved and restored after the function ends (earlier draft, probably needed but not sure which registers need saving, and which can be discarded)
000021F4                          1938  Move_operation:
000021F4  2607                    1939          MOVE.L D7,D3
000021F6  0283 000001C0           1940          ANDI.L #Move_Destination_Mode,D3
000021FC  3A3C 0006               1941          MOVE #6,D5
00002200  EAAB                    1942          LSR.L D5,D3
00002202  0C03 0001               1943          CMPI.B #1,D3
00002206  6700 0012               1944          BEQ Move_Address
0000220A                          1945  Standard_Move     
0000220A  45F9 00002AF9           1946          LEA Move_op, A2 * loads address of "MOVE" op string to A2 buffer
00002210  4EB9 00002972           1947          JSR Start_String_Appending 
00002216  6000 000E               1948          BRA Subtype_Decided
0000221A                          1949  Move_Address
0000221A  45F9 00002AFE           1950          LEA MoveA_op,A2 * loads address of "MOVEA" op string to A2 buffer
00002220  4EB9 00002972           1951          JSR Start_String_Appending
00002226                          1952  Subtype_Decided
00002226  2607                    1953          MOVE.L D7,D3    * Move converted hex value to D3, again
00002228  0283 00003000           1954          ANDI.L #$3000, D3 * compare second two bytes of hex value to check the size of the operation (byte, word, long)
0000222E  3A3C 000C               1955          MOVE #12,D5     * prepare shifting by the value 28 again, for least significant repositioning of size field
00002232  EAAB                    1956          LSR.L D5,D3     * shift the bits in D3 by value in D5 (28)
00002234  0C03 0003               1957          CMPI.B #3,D3    * statement checks if size is word
00002238  6700 002E               1958          BEQ Word_Operation * executes if true
0000223C  0C03 0001               1959          CMPI.B #1,D3    * CMPI statement checks if size if byte
00002240  6700 000E               1960          BEQ Byte_Operation * executes if true
00002244  0C03 0002               1961          CMPI.B #2,D3    * CMPI statement checks if size is long
00002248  6700 0036               1962          BEQ Long_Operation * executes if true
0000224C  6000 042E               1963          BRA Error_Mode
00002250                          1964         
00002250                          1965  * function prints out byte modifier (.B) 
00002250                          1966  Byte_Operation: 
00002250  45F9 00002B8B           1967          LEA Byte_Size,A2
00002256                          1968          *TRAP #15
00002256  363C 0004               1969          MOVE #4,D3
0000225A  4EB9 00002972           1970          JSR Start_String_Appending
00002260  367C 0001               1971          MOVE #1,A3
00002264  6000 00B0               1972          BRA Size_Confirmed
00002268                          1973  
00002268                          1974  * function prints out word modifier (.W)
00002268                          1975  Word_Operation:
00002268  45F9 00002B87           1976          LEA Word_Size,A2
0000226E                          1977          *TRAP #15
0000226E  363C 000C               1978          MOVE #12,D3
00002272  4EB9 00002972           1979          JSR Start_String_Appending
00002278  367C 0002               1980          MOVE #2,A3
0000227C  6000 0098               1981          BRA Size_Confirmed
00002280                          1982          
00002280                          1983  * function prints out long modifier (.L)
00002280                          1984  Long_Operation:
00002280  45F9 00002B8F           1985          LEA Long_Size,A2
00002286                          1986          *TRAP #15
00002286  363C 001C               1987          MOVE #28,D3
0000228A  4EB9 00002972           1988          JSR Start_String_Appending
00002290  367C 0003               1989          MOVE #3,A3
00002294  6000 0080               1990          BRA Size_Confirmed
00002298                          1991  
00002298                          1992  * function prints out the specific register that is specified by the opcode word (uses flags to indicate which field to process)
00002298                          1993  * D5 is holding the #of bits to be shifted right
00002298                          1994  R_Destination:
00002298  48E7 1000               1995          MOVEM.L Move_Registers,-(SP)
0000229C  2607                    1996          MOVE.L D7,D3
0000229E  0C02 0001               1997          CMPI.B #1,D2
000022A2  6700 000C               1998          BEQ GetDestinationReg
000022A6                          1999          
000022A6                          2000  GetSourceReg                                    * for Standard Move instruction
000022A6  0283 00000007           2001          ANDI.L #Move_Source_Register,D3
000022AC  6000 000E               2002          BRA After_Decision
000022B0                          2003          
000022B0                          2004  GetDestinationReg
000022B0  0283 00000E00           2005          ANDI.L #Move_Destination_Register,D3 * for standard Move instruction
000022B6  3A3C 0009               2006          MOVE #9,D5
000022BA  EAAB                    2007          LSR.L D5,D3
000022BC                          2008          
000022BC                          2009  After_Decision 
000022BC  4EB9 000022F4           2010          JSR Decision_Register * check if D4 is 1 to confirm if effective address involves address register
000022C2  3203                    2011          MOVE D3,D1    * move determined register number into D1
000022C4  363C 0000               2012          MOVE #0,D3
000022C8  4EB9 000029BC           2013          JSR Add_Hex_String_To_Buffer
000022CE  4CDF 0008               2014          MOVEM.L (SP)+,Move_Registers
000022D2  4E75                    2015          RTS           * return to stack
000022D4                          2016          
000022D4                          2017  * calculates the register number for the opcode (can function independently from the above function but is also accomplished in functionality by the above function, this was necessary for one of the addressing modes)
000022D4                          2018  CalculateRegisterNum:
000022D4  2607                    2019      MOVE.L D7,D3
000022D6  0C02 0001               2020      CMPI.B #1,D2
000022DA  6700 000A               2021      BEQ Destination_Calculation
000022DE                          2022      
000022DE                          2023  Source_Calculation
000022DE  0283 00000007           2024      ANDI.L #Move_Source_Register,D3
000022E4  4E75                    2025      RTS
000022E6                          2026  Destination_Calculation    
000022E6  0283 00000E00           2027      ANDI.L #Move_Destination_Register,D3
000022EC  3A3C 0009               2028      MOVE #9, D5
000022F0  EAAB                    2029      LSR.L D5,D3
000022F2  4E75                    2030      RTS
000022F4                          2031  
000022F4                          2032  Decision_Register:
000022F4  0C84 00000001           2033      CMPI.L #1,D4
000022FA  6700 0010               2034      BEQ Address_Reg
000022FE  6000 0002               2035      BRA Data_Reg
00002302                          2036      
00002302                          2037  Data_Reg 
00002302  4EB9 000028B6           2038      JSR Print_Data_Register
00002308  6000 0008               2039      BRA END
0000230C                          2040      
0000230C                          2041  Address_Reg 
0000230C  4EB9 000028C4           2042      JSR Print_Address_Register
00002312                          2043      
00002312                          2044  END 
00002312  4284                    2045      CLR.L D4
00002314  4E75                    2046      RTS
00002316                          2047  
00002316                          2048  * called when size of operation is printed, calls the DesAddressingModeDetermine
00002316                          2049  * function, which prints out the destination effective address
00002316                          2050  Size_Confirmed:
00002316  4282                    2051      CLR.L D2
00002318  4EB9 00002374           2052      JSR DestAddressingModeDetermine
0000231E  45F9 00002B9F           2053      LEA Comma,A2
00002324  4EB9 00002972           2054      JSR Start_String_Appending
0000232A  143C 0001               2055      MOVE.B #1,D2  * set flag to indicate the processing of destination operand (tells the function to process leftmost effective address)
0000232E  1C3C 003C               2056      MOVE.B #60,D6 * generalized flag for destination addresses (for the purposes of ruling out immediate data as destination)
00002332  4EB9 00002374           2057      JSR DestAddressingModeDetermine
00002338  4246                    2058      CLR D6
0000233A  4E75                    2059      RTS
0000233C                          2060          
0000233C                          2061  end_Program:
0000233C  4E72 0A8C               2062      STOP #2700
00002340                          2063      **************************************************
00002340                          2064      *Your disassembler code goes here
00002340                          2065      **************************************************
00002340                          2066      
00002340                          2067      ;Open config.cfg (trap subtasks 50-59) (this is an IO responsibility if 3 team members)
00002340                          2068      ;load start and end address as longs
00002340                          2069      
00002340                          2070      ;loop from start to end, printing out the instruction or DATA if not recognized 
00002340                          2071      ;   use my method below (printStringToFileAndConsole) to print out the individual instruction (or DATA)
00002340                          2072  
00002340  FFFF FFFF               2073      SIMHALT
00002344                          2074  
00002344                          2075  *********************************************************************************
00002344                          2076  * Method Name: NOP_Operation
00002344                          2077  * Description: call this method from your code above; see the examples above on
00002344                          2078  *   how to call methods and use them profusely as you build your final project
00002344                          2079  *
00002344                          2080  * Preconditions:  The value of the hex instruction is in D3
00002344                          2081  * Postconditions: Loads the effective address of the "NOP" op string, and calls TrapTask14 
00002344                          2082  *                 to print it out. Branches to end of program afterwards.
00002344                          2083  *********************************************************************************
00002344                          2084  NOP_Operation:
00002344  45F9 00002B0A           2085      LEA NOP_op,A2
0000234A  4EB9 00002972           2086      JSR Start_String_Appending
00002350  4EB9 00002694           2087      JSR TrapTask13
00002356  544C                    2088      ADDA #2,A4
00002358  6000 ECC2               2089      BRA start_Disassembly
0000235C                          2090      
0000235C                          2091  *********************************************************************************
0000235C                          2092  * Method Name: RTS_Operation
0000235C                          2093  * Description: call this method from your code above; see the examples above on
0000235C                          2094  *   how to call methods and use them profusely as you build your final project
0000235C                          2095  *
0000235C                          2096  * Preconditions:  The value of the hex instruction is in D3
0000235C                          2097  * Postconditions: Loads the effective address of the "RTS" op string, and calls TrapTask14 
0000235C                          2098  *                 to print it out. Branches to end of program afterwards.
0000235C                          2099  *********************************************************************************
0000235C                          2100  RTS_Operation:
0000235C  45F9 00002B0E           2101      LEA RTS_op,A2
00002362  4EB9 00002972           2102      JSR Start_String_Appending
00002368  4EB9 00002694           2103      JSR TrapTask13
0000236E  544C                    2104      ADDA #2,A4
00002370  6000 ECAA               2105      BRA start_Disassembly
00002374                          2106      
00002374                          2107  *********************************************************************************
00002374                          2108  * Method Name: DestAddressingModeDetermine
00002374                          2109  * Description: Does the processing of decoding effective addressing. Will take one of the 6 bit effective address fields and decode them into one of the 
00002374                          2110  *              supported addressing modes (Data Register Direct, Address Register Direct, Address Register Indirect (ARI), ARI PostIncrement, ARI PreDecrement). 
00002374                          2111  *              If none are decoded go to error and print "XXXXXXXX DATA YYYY". Appropriate ascii chars in accordance with the addressing mode will then be 
00002374                          2112  *              added into the string buffer.
00002374                          2113  *
00002374                          2114  * Calling Convention: Caller-Saved
00002374                          2115  *
00002374                          2116  * Preconditions & Method Input:
00002374                          2117  *   Is called by any specialized operation disassembling function after specifying which addressing field to process with D2 flag (1: 6-11 bits, 2:0-5 bits). A4 
00002374                          2118  *   references the current instruction opcode word, as well as D7.
00002374                          2119  *
00002374                          2120  * Postconditions & Output:
00002374                          2121  *   Appends to string buffer the correct assembly language equivalent of the effective addressing mode decoded.
00002374                          2122  *
00002374                          2123  *  A2 holds the address of the variable string holding the ascii char we want (i.e. "(",")","-","+","D","A", etc)
00002374                          2124  *  A3 acts as a flag for DestAdressingModeDetermine for operation size (1: byte, 2: word, 3: long)
00002374                          2125  *  D7 holds the current instruction opcode word
00002374                          2126  *  D3 holds a copy of the current instruction opcode word for allowing bit mask manipulation without losing D7 data (helps for operation size determination),
00002374                          2127  *  also is used for determining ascii hex width for buffer, and as flag for telling the functions called for absolute addressing that a long operation
00002374                          2128  *  is being done as opposed to word, can also help distinguish difference between word operands addressing modes (absolute addressing, immediate addressing)
00002374                          2129  *  D5 holds the shift value that is used to shift values in data register with shift count greater than 8
00002374                          2130  *  D2 stores a flag that tells the function which effective address bits to process (1: 6-11 bits, 2: 0-5 bits)
00002374                          2131  *  D4 holds a flag that tell the function whether the particular operation function that called it allows the particular addressing mode that's been determined.
00002374                          2132  *  If not, it can go to error (label "Error Mode")
00002374                          2133  ********************************************************************************* 
00002374                          2134  Addressing_Regs REG D1,D4,D5,D6
00002374                          2135  DestAddressingModeDetermine:
00002374  48A7 4000               2136          MOVEM Addressing_Regs,-(SP)
00002378  2607                    2137          MOVE.L D7,D3
0000237A  0C02 0001               2138          CMPI.B #1,D2
0000237E  6600 0012               2139          BNE source_Operand
00002382                          2140  destination_Operand 
00002382  0283 000001C0           2141          ANDI.L #Move_Destination_Mode,D3
00002388  3A3C 0006               2142          MOVE #6,D5
0000238C  EAAB                    2143          LSR.L D5,D3
0000238E  6000 000E               2144          BRA decided_Operand
00002392                          2145  source_Operand
00002392  0283 00000038           2146          ANDI.L #Move_Source_Mode,D3
00002398  3A3C 0003               2147          MOVE #3,D5
0000239C  EAAB                    2148          LSR.L D5,D3
0000239E                          2149  decided_Operand
0000239E  0C03 0000               2150          CMPI.B #0,D3
000023A2  6700 020A               2151          BEQ Data_Reg_Direct
000023A6  0C03 0001               2152          CMPI.B #1,D3
000023AA  6700 0026               2153          BEQ Address_Reg_Direct
000023AE                          2154     *     JSR R_Destination * handles Data register direct
000023AE  0C03 0002               2155          CMPI.B #2,D3 * handles Address register indirect
000023B2  6700 00A4               2156          BEQ Address_Reg_Indirect
000023B6  0C03 0003               2157          CMPI.B #3,D3
000023BA  6700 00D4               2158          BEQ Address_Reg_Indir_Post_Inc * handles Address register indirect with post increment
000023BE  0C03 0004               2159          CMPI.B #4,D3
000023C2  6700 0122               2160          BEQ Address_Reg_Indir_Pre_Dec * handles Address register indirect with pre decrement
000023C6  0C03 0007               2161          CMPI.B #7,D3
000023CA  6700 016E               2162          BEQ Absolute_Addressing
000023CE  6000 02AC               2163          BRA Error_Mode
000023D2                          2164   
000023D2                          2165  Address_Reg_Direct       
000023D2                          2166        * CMPI.B #1,D2
000023D2                          2167        * BEQ Error_Mode
000023D2  0C44 000F               2168         CMPI #15,D4            * checks if operation is BCLR
000023D6  6700 0078               2169         BEQ BCLR_A
000023DA  0C44 0062               2170         CMPI #98,D4
000023DE  6700 0070               2171         BEQ BCLR_A
000023E2  0C44 0054               2172         CMPI #84,D4  * indicates that the operation is a byte size SUBQ operation or a MULS.W operation
000023E6  6700 0068               2173         BEQ BCLR_A
000023EA  0C44 0063               2174         CMPI #99,D4
000023EE  6700 0060               2175         BEQ BCLR_A
000023F2  0C44 0194               2176         CMPI #404,D4
000023F6  6700 0058               2177         BEQ BCLR_A
000023FA  0C44 005C               2178         CMPI #92,D4
000023FE  6700 0050               2179         BEQ BCLR_A
00002402  0C44 0032               2180         CMPI #50,D4
00002406  6700 0048               2181         BEQ BCLR_A
0000240A  0C44 0037               2182         CMPI #55,D4
0000240E  6700 0040               2183         BEQ BCLR_A
00002412  0C44 0190               2184         CMPI #400,D4
00002416  6700 0038               2185         BEQ BCLR_A
0000241A  0C44 01F4               2186         CMPI #500,D4 * checks for NEG Operation
0000241E  6700 0030               2187         BEQ BCLR_A
00002422  0C44 001B               2188         CMPI #27,D4
00002426  6700 0028               2189         BEQ BCLR_A
0000242A  0C44 001F               2190         CMPI #31,D4
0000242E  6700 0020               2191         BEQ BCLR_A
00002432                          2192  After_BCLR_Decision
00002432                          2193  MOVEM_Check
00002432  0C44 0042               2194         CMPI #66,D4 * indicates a register to memory transfer for a MOVEM instruction
00002436  6700 0244               2195         BEQ Error_Mode
0000243A  0C44 0041               2196         CMPI #65,D4 * indicates a memory to register transfer for a MOVEM instruction
0000243E  6700 023C               2197         BEQ Error_Mode
00002442  383C 0001               2198         MOVE #1,D4
00002446  4EB8 2298               2199         JSR R_Destination
0000244A  4284                    2200         CLR.L D4
0000244C  6000 0240               2201         BRA END_EFF_ADD
00002450                          2202  BCLR_A                   * also indicates other operations that forbid this effective address in certain positions (source or destination)
00002450  6000 022A               2203         BRA Error_Mode
00002454  6000 0238               2204         BRA END_EFF_ADD
00002458                          2205         
00002458                          2206  Address_Reg_Indirect
00002458  0C44 000F               2207          CMPI #15,D4
0000245C  6600 0018               2208          BNE After_AReg_In
00002460                          2209  BCLR_ARegIn
00002460  45F9 00002B8B           2210          LEA Byte_Size,A2
00002466  4EB9 00002972           2211          JSR Start_String_Appending
0000246C  4EB8 1D0E               2212          JSR BCLR_Data_Register_Print
00002470  4EB9 000028FC           2213          JSR Add_Comma       
00002476                          2214  After_AReg_In
00002476  383C 0001               2215          MOVE #1,D4
0000247A  4EB9 00002772           2216          JSR OpenParen
00002480  4EB8 2298               2217          JSR R_Destination
00002484  4284                    2218          CLR.L D4
00002486  4EB9 00002780           2219          JSR CloseParen
0000248C  6000 0200               2220          BRA END_EFF_ADD
00002490                          2221              
00002490                          2222  Address_Reg_Indir_Post_Inc
00002490  0C44 000F               2223          CMPI #15,D4
00002494  6600 0018               2224          BNE After_AReg_InPost
00002498                          2225  BCLR_ARegInPost
00002498  45F9 00002B8B           2226          LEA Byte_Size,A2
0000249E  4EB9 00002972           2227          JSR Start_String_Appending
000024A4  4EB8 1D0E               2228          JSR BCLR_Data_Register_Print
000024A8  4EB9 000028FC           2229          JSR Add_Comma           
000024AE                          2230  After_AReg_InPost
000024AE  0C44 0042               2231          CMPI #66,D4
000024B2  6700 01C8               2232          BEQ Error_Mode
000024B6  0C44 0037               2233          CMPI #55,D4
000024BA  6700 01C0               2234          BEQ Error_Mode
000024BE  0C44 0190               2235          CMPI #400,D4
000024C2  6700 01B8               2236          BEQ Error_Mode
000024C6  383C 0001               2237          MOVE #1,D4
000024CA  4EB9 00002772           2238          JSR OpenParen
000024D0  4EB8 2298               2239          JSR R_Destination
000024D4  4EB9 00002780           2240          JSR CloseParen
000024DA  4EB9 0000278E           2241          JSR AddPostIncrement
000024E0  4284                    2242          CLR.L D4
000024E2  6000 01AA               2243          BRA END_EFF_ADD
000024E6                          2244  
000024E6                          2245  Address_Reg_Indir_Pre_Dec
000024E6  0C44 000F               2246          CMPI #15,D4
000024EA  6600 0018               2247          BNE After_AReg_InPre
000024EE                          2248  BCLR_ARegInPre
000024EE  45F9 00002B8B           2249          LEA Byte_Size,A2
000024F4  4EB9 00002972           2250          JSR Start_String_Appending
000024FA  4EB8 1D0E               2251          JSR BCLR_Data_Register_Print
000024FE  4EB9 000028FC           2252          JSR Add_Comma       
00002504                          2253  After_AReg_InPre
00002504  0C44 0041               2254          CMPI #65,D4
00002508  6700 0172               2255          BEQ Error_Mode
0000250C  0C44 0037               2256          CMPI #55,D4
00002510  6700 016A               2257          BEQ Error_Mode
00002514  0C44 0190               2258          CMPI #400,D4
00002518  6700 0162               2259          BEQ Error_Mode
0000251C  383C 0001               2260          MOVE #1,D4
00002520  4EB9 0000279C           2261          JSR AddPreDecrement
00002526  4EB9 00002772           2262          JSR OpenParen
0000252C  4EB8 2298               2263          JSR R_Destination
00002530  4EB9 00002780           2264          JSR CloseParen
00002536  6000 0156               2265          BRA END_EFF_ADD
0000253A                          2266              
0000253A                          2267  Absolute_Addressing
0000253A  0C44 000F               2268          CMPI #15,D4
0000253E  6600 0018               2269          BNE After_Absolute
00002542                          2270  BCLR_Absolute
00002542  45F9 00002B8B           2271          LEA Byte_Size,A2
00002548  4EB9 00002972           2272          JSR Start_String_Appending
0000254E  4EB8 1D0E               2273          JSR BCLR_Data_Register_Print
00002552  4EB9 000028FC           2274          JSR Add_Comma
00002558                          2275  After_Absolute
00002558  4EB8 22D4               2276          JSR CalculateRegisterNum
0000255C  0C03 0004               2277          CMPI.B #4,D3
00002560  6700 00B6               2278          BEQ Immediate_Addressing
00002564  0C03 0000               2279          CMPI.B #0,D3
00002568  6700 0012               2280          BEQ Absolute_Address_Word
0000256C  0C03 0001               2281          CMPI.B #1,D3
00002570  6700 0006               2282          BEQ Set_D3_For_Long_Operand_Flag
00002574  6000 0118               2283          BRA END_EFF_ADD
00002578                          2284  
00002578                          2285  Set_D3_For_Long_Operand_Flag
00002578  363C 0005               2286          MOVE #5,D3
0000257C                          2287  
0000257C                          2288  Absolute_Address_Word
0000257C  4EB9 000027AA           2289          JSR AddHexCash
00002582  4EB9 000027DC           2290          JSR IsolateSecondInstrWord
00002588  2206                    2291          MOVE.L D6,D1
0000258A  0C44 0190               2292          CMPI #400,D4
0000258E  6600 0006               2293          BNE After_LEA_Decision
00002592                          2294  Force_LEA_Long
00002592  363C 001C               2295          MOVE #28,D3
00002596                          2296  After_LEA_Decision
00002596  0C44 01F4               2297          CMPI #500,D4
0000259A  6600 0004               2298          BNE AfterNegMoveDecision
0000259E                          2299  MoveSizeIdentifier
0000259E  3600                    2300          MOVE D0,D3
000025A0                          2301  AfterNegMoveDecision
000025A0  363C 001C               2302          MOVE #28,D3
000025A4  4EB9 000029BC           2303          JSR Add_Hex_String_To_Buffer
000025AA  6000 00E2               2304          BRA END_EFF_ADD
000025AE                          2305  
000025AE                          2306  Data_Reg_Direct
000025AE  0C44 000F               2307          CMPI #15,D4
000025B2  6600 001C               2308          BNE MOVEM_Proc
000025B6                          2309  BCLR_Proc
000025B6  45F9 00002B8F           2310          LEA Long_Size,A2
000025BC  4EB9 00002972           2311          JSR Start_String_Appending
000025C2  4EB8 1D0E               2312          JSR BCLR_Data_Register_Print
000025C6  4EB9 000028FC           2313          JSR Add_Comma
000025CC  6000 0042               2314          BRA After_Op_Decided
000025D0                          2315  MOVEM_Proc                      * also checks if its anything other than a BCLR instruction
000025D0  0C44 0015               2316          CMPI #21,D4
000025D4  6700 003A               2317          BEQ After_op_Decided
000025D8  0C44 001F               2318          CMPI #31,D4
000025DC  6700 009E               2319          BEQ Error_Mode
000025E0  0C44 005C               2320          CMPI #92,D4
000025E4  6700 0096               2321          BEQ Error_Mode
000025E8  0C44 0194               2322          CMPI #404,D4
000025EC  6700 008E               2323          BEQ Error_Mode
000025F0  0C44 0042               2324          CMPI #66,D4
000025F4  6700 0086               2325          BEQ Error_Mode
000025F8  0C44 0041               2326          CMPI #65,D4
000025FC  6700 007E               2327          BEQ Error_Mode
00002600  0C44 0037               2328          CMPI #55,D4
00002604  6700 0076               2329          BEQ Error_Mode
00002608  0C44 0190               2330          CMPI #400,D4
0000260C  6700 006E               2331          BEQ Error_Mode
00002610                          2332  After_Op_Decided
00002610  4EB8 2298               2333          JSR R_Destination
00002614  6000 0078               2334          BRA END_EFF_ADD
00002618                          2335      
00002618                          2336  Immediate_Addressing
00002618  0C46 003C               2337          CMPI #60,D6 * Generalized check for destination operand processing
0000261C  6700 005E               2338          BEQ Error_Mode
00002620  0C44 0042               2339          CMPI #66,D4
00002624  6700 0056               2340          BEQ Error_Mode
00002628  0C44 0194               2341          CMPI #404,D4
0000262C  6700 004E               2342          BEQ Error_Mode
00002630  0C44 005C               2343          CMPI #92,D4
00002634  6700 0046               2344          BEQ Error_Mode
00002638  0C44 0063               2345          CMPI #99,D4
0000263C  6700 003E               2346          BEQ Error_Mode
00002640  0C44 0041               2347          CMPI #65,D4
00002644  6700 0036               2348          BEQ Error_Mode
00002648  0C44 001B               2349          CMPI #27,D4
0000264C  6700 002E               2350          BEQ Error_Mode
00002650  0C44 001F               2351          CMPI #31,D4
00002654  6700 0026               2352          BEQ Error_Mode
00002658  0C02 0001               2353          CMPI.B #1,D2
0000265C  6700 001E               2354          BEQ Error_Mode
00002660  4EB9 000027B8           2355          JSR AddPoundSign
00002666  4EB9 000027AA           2356          JSR AddHexCash
0000266C  4EB9 00002856           2357          JSR IsolateInstrOperands
00002672  4EB9 000029BC           2358          JSR Add_Hex_String_To_Buffer
00002678  6000 0014               2359          BRA END_EFF_ADD
0000267C                          2360  
0000267C                          2361  Error_Mode        
0000267C  4EB9 00002A06           2362          JSR Error_Subroutine
00002682  4C9F 0002               2363          MOVEM (SP)+,Addressing_Regs
00002686  4286                    2364          CLR.L D6
00002688  D8C0                    2365          ADDA D0,A4
0000268A  6000 E990               2366          BRA start_Disassembly
0000268E                          2367          
0000268E                          2368  END_EFF_ADD
0000268E  4C9F 0002               2369          MOVEM (SP)+,Addressing_Regs     
00002692  4E75                    2370          RTS
00002694                          2371  *********************************************************************************
00002694                          2372  * Method Name: TrapTask13
00002694                          2373  * Description: Creates a file if none exists, and appends bytes to that file
00002694                          2374  *   while also echoing the written bytes to the screen.  You shouldn't need to
00002694                          2375  *   change this code.
00002694                          2376  *
00002694                          2377  * Calling Convention: Callee-Saved 
00002694                          2378  *
00002694                          2379  * Preconditions & Method Input:
00002694                          2380  *   A1 points to the null-terminated buffer to write (newline will be added for you)
00002694                          2381  *
00002694                          2382  * Postconditions & Output:
00002694                          2383  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
00002694                          2384  *   See 'Output.txt' in directory for the results, also piped to the console
00002694                          2385  *
00002694                          2386  *
00002694                          2387  *  A2 holds a pointer to null terminated string to write (input)
00002694                          2388  *  A3 points to the null-terminated file name
00002694                          2389  *  D3 holds the number of bytes already in the file to write
00002694                          2390  *
00002694                          2391  *  D5 holds number of bytes to write
00002694                          2392  ********************************************************************************
00002694                          2393  toSave REG D0-D5/A2-A3
00002694                          2394  TrapTask13:
00002694                          2395      *******************************************************************
00002694                          2396      * Method initialization, regsiter spilling, parameter saving, etc.
00002694                          2397      *******************************************************************
00002694  48E7 FC30               2398      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
00002698                          2399        
00002698  2449                    2400      MOVEA.L A1, A2 ; save this buffer to write
0000269A  47F9 00002AD5           2401      LEA outFilename, A3  ; save this for later, too
000026A0                          2402        
000026A0  303C 0032               2403      move #50,d0   
000026A4  4E4F                    2404      trap #15 ; close all files, suggested to begin any IO 
000026A6                          2405      *******************************************************************
000026A6                          2406      * End Method Init
000026A6                          2407      *******************************************************************
000026A6                          2408  
000026A6                          2409      ******************************************************************************************
000026A6                          2410      * Calculate the number of bytes to write by searching for the null in the target buffer A0
000026A6                          2411      ******************************************************************************************
000026A6  4285                    2412      CLR.L D5 *D5 is now the number of bytes to write
000026A8                          2413  nullLoop:
000026A8  1019                    2414      MOVE.B (A1)+, D0
000026AA  0C00 0000               2415      CMPI.B #0,D0  * compare to null
000026AE  6700 0006               2416      BEQ findNullLoopDone
000026B2  5245                    2417      ADDI.W #1, D5
000026B4  60F2                    2418      BRA nullLoop
000026B6                          2419      
000026B6                          2420  findNullLoopDone:
000026B6  224B                    2421      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
000026B8                          2422      
000026B8                          2423      ;check if file exists, and open with task 51 if so, otherwise 52
000026B8                          2424      ;(precondition here is A1 points to the null-terminated filename )
000026B8  103C 0033               2425      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
000026BC  4E4F                    2426      trap #15
000026BE                          2427        
000026BE                          2428      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
000026C4  103C 0034               2429          MOVE.B #52, D0             ; open new file (52 is new)
000026C8  4E4F                    2430          trap #15
000026CA                          2431      endi
000026CA                          2432      
000026CA                          2433      ********************************************************************************************************* 
000026CA                          2434      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
000026CA                          2435      *    (first, count number of bytes already in the file to obtain seek position)
000026CA                          2436      *********************************************************************************************************
000026CA  4283                    2437      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
000026CC  7401                    2438      MOVE.L #1, D2 ; read one byte at a time
000026CE  43F9 00002AEB           2439      LEA byteRead, A1
000026D4                          2440      
000026D4                          2441  countLoop:
000026D4  103C 0035               2442      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
000026D8  4E4F                    2443      trap #15
000026DA                          2444      
000026DA  0C40 0001               2445      CMPI.W #1,D0  ;1 == EOF
000026DE  6700 0006               2446      BEQ countDone
000026E2  5243                    2447      ADDI #1, D3
000026E4  60EE                    2448      BRA countLoop
000026E6                          2449      
000026E6                          2450  countDone:    
000026E6                          2451      * close this file
000026E6  303C 0038               2452       move #56,d0  
000026EA  4E4F                    2453       trap #15 
000026EC                          2454       
000026EC                          2455       * reopen the target file
000026EC  224B                    2456       MOVE.L A3,A1
000026EE  303C 0033               2457       MOVE #51, D0
000026F2  4E4F                    2458       trap #15
000026F4                          2459       
000026F4                          2460      * seek to right position, then continue with writing
000026F4  2403                    2461      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000026F6  303C 0037               2462      MOVE #55, D0  ; position file task
000026FA  4E4F                    2463      trap #15
000026FC                          2464  
000026FC                          2465      ******************************************************************************
000026FC                          2466      * Actually write the buffer to the file, after caculating the number of bytes 
000026FC                          2467      *  to write and after seeking to the right location in the file for append
000026FC                          2468      ******************************************************************************
000026FC                          2469  
000026FC  2405                    2470      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000026FE                          2471      ; assumes A0 hasnt changed since handed to this method      
000026FE  224A                    2472      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
00002700                          2473      ; assumes file ID is still stored in D1.L  
00002700  103C 0036               2474      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
00002704  4E4F                    2475      trap #15
00002706                          2476  
00002706                          2477      ; add a newline to the file output
00002706  43F9 00002A9C           2478      LEA NEWLINE, A1
0000270C  103C 0036               2479      MOVE.B #54, D0 
00002710  143C 0002               2480      MOVE.B #2,D2  ; kills # of bytes to write from input param
00002714  4E4F                    2481      trap #15
00002716                          2482      
00002716                          2483      ; finally, close only this file
00002716  103C 0038               2484      MOVE.B #56, D0 ; close file task
0000271A  4E4F                    2485      trap #15
0000271C                          2486    
0000271C                          2487      ; report to screen
0000271C  224A                    2488      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
0000271E  103C 000D               2489      MOVE.B #13, D0
00002722  4E4F                    2490      trap #15
00002724                          2491        
00002724                          2492      ; restore context
00002724  4CDF 0C3F               2493      MOVEM.L (SP)+, toSave
00002728                          2494      
00002728  4E75                    2495      RTS
0000272A                          2496      
0000272A                          2497      
0000272A                          2498  *----------------------------------------------------------------------------------
0000272A                          2499  * Method Name: AsciiToHex
0000272A                          2500  * Written by : Berger, Modified by Nash
0000272A                          2501  * Date       : 3/1/2019
0000272A                          2502  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
0000272A                          2503  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
0000272A                          2504  *              its (4b each) equivalent hex value 
0000272A                          2505  *  
0000272A                          2506  *  Preconditions & Input
0000272A                          2507  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
0000272A                          2508  *       This function calls another function (strip_ascii)
0000272A                          2509  *
0000272A                          2510  *  Postconditions & Output
0000272A                          2511  *       D7 (output) holds the converted value 
0000272A                          2512  *       Caller-Saved : D0 is temp, D6 is a loop var
0000272A                          2513  *----------------------------------------------------------------------------------
0000272A                          2514  AsciiToHexRegList REG D0,D6
0000272A                          2515  AsciiToHex     
0000272A  48E7 8000               2516      MOVEM.L asciiToHexRegList, -(SP)  *save context
0000272E  4287                    2517      CLR.L D7 * clear our return value
00002730  7C08                    2518      MOVE.L #8, D6 ; and set up our loop counter
00002732                          2519  
00002732                          2520  chrLoop
00002732  1019                    2521      MOVE.B (A1)+,D0 * Get the first byte
00002734  4EB9 0000274C           2522      jsr strip_ascii * Get rid of the ascii code    
0000273A  8E40                    2523      OR.W D0,D7 * Load the bits into D7
0000273C                          2524      
0000273C  5306                    2525      subI.B #1,D6  *decrement our loop variable
0000273E  6700 0006               2526      BEQ chrDone   *skip shifting if we are done
00002742                          2527      
00002742  E987                    2528      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
00002744  60EC                    2529      BRA chrLoop
00002746                          2530  
00002746                          2531  chrDone
00002746  4CDF 0001               2532      MOVEM.L (SP)+,asciiToHexRegList 
0000274A  4E75                    2533      RTS
0000274C                          2534  
0000274C                          2535  
0000274C                          2536  **********************************************************************
0000274C                          2537  * SUBROUTINE: strip_ascii
0000274C                          2538  * remove the ascii code from the digits 0-9,a-f, or A-F
0000274C                          2539  * Input Parameters: <D0> = ascii code
0000274C                          2540  *
0000274C                          2541  * Return parameters: D0.B = number 0...F, returned as 00...0F
0000274C                          2542  * Registers used internally: D0
0000274C                          2543  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
0000274C                          2544  *
0000274C                          2545  ***********************************************************************
0000274C                          2546  strip_ascii
0000274C  B03C 0039               2547        CMP.B #$39,D0 * Is it in range of 0-9?
00002750  6F00 001A               2548        BLE sub30 * Its a number
00002754  B03C 0046               2549        CMP.B #$46,D0 * Is is A...F?
00002758  6F00 000A               2550        BLE sub37 * Its A...F
0000275C  0400 0057               2551        SUB.B #$57,D0 * Its a...f
00002760  6000 000E               2552        BRA ret_sa * Go back
00002764  0400 0037               2553  sub37 SUB.B #$37,D0 * Strip 37
00002768  6000 0006               2554        BRA ret_sa * Go back
0000276C  0400 0030               2555  sub30 SUB.B #$30,D0 * Strip 30
00002770  4E75                    2556  ret_sa RTS * Go back
00002772                          2557      
00002772                          2558  * loads an open parenthesis into the string buffer
00002772                          2559  OpenParen:
00002772  45F9 00002B93           2560      LEA Open_Paren,A2
00002778  4EB9 00002972           2561      JSR Start_String_Appending
0000277E  4E75                    2562      RTS
00002780                          2563      
00002780                          2564  * loads a close parenthesis into the string buffer
00002780                          2565  CloseParen:
00002780  45F9 00002B95           2566      LEA Close_Paren,A2
00002786  4EB9 00002972           2567      JSR Start_String_Appending
0000278C  4E75                    2568      RTS
0000278E                          2569      
0000278E                          2570  * loads a plus sign into the string buffer
0000278E                          2571  AddPostIncrement:
0000278E  45F9 00002B97           2572      LEA Plus,A2
00002794  4EB9 00002972           2573      JSR Start_String_Appending
0000279A  4E75                    2574      RTS
0000279C                          2575      
0000279C                          2576  * loads a minus sign into the string buffer
0000279C                          2577  AddPreDecrement:
0000279C  45F9 00002B99           2578      LEA Minus,A2
000027A2  4EB9 00002972           2579      JSR Start_String_Appending
000027A8  4E75                    2580      RTS
000027AA                          2581      
000027AA                          2582  * loads a hex cash sign into the string buffer
000027AA                          2583  AddHexCash:
000027AA  45F9 00002B9B           2584      LEA HexCash,A2
000027B0  4EB9 00002972           2585      JSR Start_String_Appending
000027B6  4E75                    2586      RTS
000027B8                          2587  
000027B8                          2588  * loads a pound sign into the string buffer
000027B8                          2589  AddPoundSign:
000027B8  45F9 00002B9D           2590      LEA Pound,A2
000027BE  4EB9 00002972           2591      JSR Start_String_Appending
000027C4  4E75                    2592      RTS
000027C6                          2593  
000027C6                          2594  * loads a newline character into the string buffer
000027C6                          2595  AddNewLine:
000027C6  45F9 00002A9C           2596      LEA NEWLINE,A2
000027CC  4EB9 00002972           2597      JSR Start_String_Appending
000027D2  4E75                    2598      RTS
000027D4                          2599      
000027D4                          2600  * loads the value in A2 into the string buffer
000027D4                          2601  DisplayInHex:
000027D4  4EB9 00002972           2602      JSR Start_String_Appending
000027DA  4E75                    2603      RTS
000027DC                          2604      
000027DC                          2605  *********************************************************************************
000027DC                          2606  * Method Name: IsolateSecondInstrWord
000027DC                          2607  * Description: Processes the absolute addressing effective address mode. And places the operand words in D1.
000027DC                          2608  *
000027DC                          2609  * Calling Convention: Caller-Saved
000027DC                          2610  *
000027DC                          2611  * Preconditions & Method Input:
000027DC                          2612  *   Is called by a function initiating an absolute addressing mode. A4 is pointing to the current instruction opcode word. D0 is holding the exact displacement count
000027DC                          2613  *   of moves forward from the opcode made over the course of the current instruction (over the course of the same A4 value). D3 is flagged with whatever value
000027DC                          2614  *   is needed to specify the correct word length intended (D3 needs to be 5 for a long absolute address operation to be initiated, anything else is word)
000027DC                          2615  *
000027DC                          2616  * Postconditions & Output:
000027DC                          2617  *   Places the completely processed operand words into D1, resets the value of A4 to what it was when the function was called. A hex to ascii width specifier in
000027DC                          2618  *   D3
000027DC                          2619  *
000027DC                          2620  *  A6 holds a pointer to where A4 is pointing at, but is allowed to be added to in accordance with what operands need to be fetched.
000027DC                          2621  *  D0 holds the counter of displacements made from the current value of A4 (and thus the value that needs to be added to A4 at the end of the current instruction
000027DC                          2622  *  , unless an error ("XXXXXXXX DATA YYYY") is reached)
000027DC                          2623  *  A4 the pointer to the current instruction opcode word
000027DC                          2624  *  D4 acts as a flag that specifies certain kinds of instructions that need to be processed differently
000027DC                          2625  *  D3 acts as a flag telling the function to either do a long operation (D3 == 5), or not (D3 == anything else), D3 also acts as a hex to ascii width specifier
000027DC                          2626  *  as an output value of the function
000027DC                          2627  *  D2 is a holder for a shift count value for a data register shift, since the value required is greater than #8, this is necessary
000027DC                          2628  *  D6 holds the full operand word to be returned by the function (is moved to D1 later on by the end of the function)
000027DC                          2629  ********************************************************************************
000027DC                          2630  IsolateSecondInstrWord:
000027DC  48A7 2000               2631      MOVEM D2,-(SP)
000027E0                          2632      *MOVE D7,D6
000027E0  2C4C                    2633      MOVE.L A4,A6
000027E2  0C44 0041               2634      CMPI #65,D4
000027E6  6700 0012               2635      BEQ AddingForMoveM
000027EA  0C44 0042               2636      CMPI #66,D4
000027EE  6700 000A               2637      BEQ AddingForMoveM
000027F2                          2638  AddingForNonMoveM    * also for BCLR Dynamic
000027F2  DCC0                    2639      ADDA D0,A6
000027F4  5440                    2640      ADD #2,D0
000027F6  6000 0006               2641      BRA AfterMoveMDecision
000027FA                          2642  AddingForMoveM
000027FA  584E                    2643      ADDA #4,A6
000027FC  5840                    2644      ADDI #4,D0
000027FE                          2645  AfterMoveMDecision
000027FE  4286                    2646      CLR.L D6
00002800  3C16                    2647      MOVE (A6),D6
00002802  0C43 0005               2648      CMPI #5,D3
00002806  6600 002A               2649      BNE  Just_A_Word
0000280A  2C4C                    2650      MOVE.L A4,A6
0000280C  DCC0                    2651      ADD D0,A6
0000280E  0C44 0041               2652      CMPI #65,D4
00002812  6700 000C               2653      BEQ After_Potential_D0_Increment
00002816  0C44 0042               2654      CMPI #66,D4
0000281A  6700 0004               2655      BEQ After_Potential_D0_Increment
0000281E  5440                    2656      ADDI #2,D0
00002820                          2657  After_Potential_D0_Increment
00002820  343C 0010               2658      MOVE #16,D2
00002824  E5AE                    2659      LSL.L D2,D6
00002826  3C16                    2660      MOVE.W (A6),D6
00002828  363C 001C               2661      MOVE #28,D3
0000282C  2206                    2662      MOVE.L D6,D1
0000282E  6000 001E               2663      BRA Fin_Isol
00002832                          2664  Just_A_Word
00002832  363C 000C               2665      MOVE #12,D3
00002836  3206                    2666      MOVE.W D6,D1
00002838  0C44 0041               2667      CMPI #65,D4
0000283C  6700 000E               2668      BEQ MOVEM_Subtract
00002840  0C44 0042               2669      CMPI #66,D4
00002844  6700 0006               2670      BEQ MOVEM_Subtract
00002848  6000 0004               2671      BRA Fin_Isol
0000284C                          2672  MOVEM_Subtract
0000284C  5540                    2673      SUB #2,D0
0000284E                          2674  Fin_Isol
0000284E  2C4C                    2675      MOVE.L A4,A6
00002850  4C9F 0004               2676      MOVEM (SP)+,D2
00002854  4E75                    2677      RTS   
00002856                          2678      
00002856                          2679  * same as above, but for Immediate Addressing only (except Bcc which uses this with displacement)
00002856                          2680  IsolateInstrOperands:
00002856  48A7 2000               2681      MOVEM D2,-(SP)
0000285A                          2682      *MOVE D7,D6
0000285A  544E                    2683      ADDA #2,A6
0000285C  5440                    2684      ADDI #2,D0
0000285E  B6FC 0001               2685      CMPA #1,A3
00002862  6700 0016               2686      BEQ IsolateByte
00002866  B6FC 0002               2687      CMPA #2,A3
0000286A  6700 0022               2688      BEQ IsolateWord
0000286E  B6FC 0003               2689      CMPA #3,A3
00002872  6700 0026               2690      BEQ IsolateLong
00002876  6000 0038               2691      BRA Fin_Isol2
0000287A                          2692  IsolateByte
0000287A  3C16                    2693      MOVE.W (A6),D6
0000287C  0246 00FF               2694      ANDI #$00FF,D6
00002880  3206                    2695      MOVE.W D6,D1
00002882  0241 00FF               2696      ANDI #$00FF,D1
00002886  363C 0004               2697      MOVE #4,D3
0000288A  6000 0024               2698      BRA Fin_Isol2
0000288E                          2699  IsolateWord
0000288E  3C16                    2700      MOVE.W (A6),D6
00002890  3206                    2701      MOVE.W D6,D1
00002892  363C 000C               2702      MOVE #12,D3
00002896  6000 0018               2703      BRA Fin_Isol2
0000289A                          2704  IsolateLong
0000289A  4286                    2705      CLR.L D6
0000289C  3C16                    2706      MOVE (A6),D6
0000289E  343C 0010               2707      MOVE #16,D2
000028A2  E5AE                    2708      LSL.L D2,D6
000028A4  544E                    2709      ADDA #2,A6
000028A6  5440                    2710      ADDI #2,D0
000028A8  3C16                    2711      MOVE.W (A6),D6
000028AA  2206                    2712      MOVE.L D6,D1
000028AC  363C 001C               2713      MOVE #28,D3
000028B0                          2714  Fin_Isol2
000028B0  4C9F 0004               2715      MOVEM (SP)+,D2
000028B4  4E75                    2716      RTS   
000028B6                          2717      
000028B6                          2718  ** loads an data register letter "D", into the string buffer
000028B6                          2719  Print_Data_Register:
000028B6  45F9 00002B83           2720      LEA Data_Register,A2
000028BC  4EB9 00002972           2721      JSR Start_String_Appending
000028C2  4E75                    2722      RTS
000028C4                          2723      
000028C4                          2724  ** loads an address register letter "A" into the string buffer
000028C4                          2725  Print_Address_Register:
000028C4  45F9 00002B85           2726      LEA Address_Register,A2
000028CA  4EB9 00002972           2727      JSR Start_String_Appending
000028D0  4E75                    2728      RTS
000028D2                          2729      
000028D2                          2730  ** place the contents of D7 into D3
000028D2                          2731  Place_D7_in_D3
000028D2  2607                    2732      MOVE.L D7,D3
000028D4  4E75                    2733      RTS
000028D6                          2734      
000028D6                          2735  ** increment the A4 disassembler memory region pointer
000028D6                          2736  Increment_Function
000028D6  5440                    2737      ADDI #2,D0
000028D8  4E75                    2738      RTS
000028DA                          2739      
000028DA                          2740  ** print the address register specified by the calling MOVEM disassembling function
000028DA                          2741  MOVEM_PreDecrement
000028DA  3C3C 0007               2742          MOVE #7,D6
000028DE  9C45                    2743          SUB D5,D6
000028E0  3A06                    2744          MOVE D6,D5
000028E2  4EB8 21C8               2745          JSR CallAPrintNumber
000028E6  4EB9 00002918           2746          JSR Add_Slash
000028EC  4E75                    2747          RTS
000028EE                          2748  
000028EE                          2749  ** print the data register specified by the calling MOVEM disassembling function
000028EE                          2750  MOVEM_PreDecrement_Rev
000028EE  9A42                    2751          SUB D2,D5
000028F0  4EB8 21AE               2752          JSR CallDPrintNumber
000028F4  4EB9 00002918           2753          JSR Add_Slash
000028FA  4E75                    2754          RTS
000028FC                          2755  
000028FC                          2756  ** loads a comma into the string buffer
000028FC                          2757  Add_Comma
000028FC  45F9 00002B9F           2758          LEA Comma,A2
00002902  4EB9 00002972           2759          JSR Start_String_Appending
00002908  4E75                    2760          RTS
0000290A                          2761          
0000290A                          2762  ** loads an empty space into the string buffer
0000290A                          2763  Add_Space
0000290A  45F9 00002BA3           2764          LEA Empty_Space,A2
00002910  4EB9 00002972           2765          JSR Start_String_Appending
00002916  4E75                    2766          RTS
00002918                          2767          
00002918                          2768  ** loads a slash into the string buffer
00002918                          2769  Add_Slash
00002918  45F9 00002BA1           2770          LEA Slash,A2
0000291E  4EB9 00002972           2771          JSR Start_String_Appending
00002924  4E75                    2772          RTS
00002926                          2773  
00002926                          2774  ** loads a "DATA" string into the string buffer
00002926                          2775  Print_Error
00002926  45F9 00002AF4           2776          LEA Print_Data_Error,A2
0000292C  4EB9 00002972           2777          JSR Start_String_Appending
00002932  4E75                    2778          RTS
00002934                          2779  
00002934                          2780  ** isolates a register of an LSd instruction opcode
00002934                          2781  LSd_Register_Mask_Isolate
00002934  48A7 0400               2782          MOVEM D5,-(SP)
00002938  0243 0E00               2783          ANDI #$0E00,D3
0000293C  3A3C 0009               2784          MOVE #9,D5
00002940  EAAB                    2785          LSR.L D5,D3
00002942  4C9F 0020               2786          MOVEM (SP)+,D5
00002946  4E75                    2787          RTS
00002948                          2788  
00002948                          2789  ** loads a byte specifier into the string buffer
00002948                          2790  Byte_Print
00002948  45F9 00002B8B           2791          LEA Byte_Size,A2
0000294E  4EB9 00002972           2792          JSR Start_String_Appending
00002954  4E75                    2793          RTS    
00002956                          2794      
00002956                          2795  ** loads a word specifier into the string buffer
00002956                          2796  Word_Print
00002956  45F9 00002B87           2797          LEA Word_Size,A2
0000295C  4EB9 00002972           2798          JSR Start_String_Appending
00002962  4E75                    2799          RTS
00002964                          2800  
00002964                          2801  ** loads a long specifier into the string buffer
00002964                          2802  Long_Print
00002964  45F9 00002B8F           2803          LEA Long_Size,A2
0000296A  4EB9 00002972           2804          JSR Start_String_Appending
00002970  4E75                    2805          RTS
00002972                          2806  
00002972                          2807  
00002972                          2808  *********************************************************************************
00002972                          2809  * Method Name: Start_String_Appending
00002972                          2810  * Description: Takes the null-terminated string at pointed to by A2, and appends it to the string buffer, which is pointed to by A5. Continues to loop
00002972                          2811  *              through string pointed to by A2 until null-character is detected. 
00002972                          2812  *
00002972                          2813  * Calling Convention: Caller-Saved
00002972                          2814  *
00002972                          2815  * Preconditions & Method Input:
00002972                          2816  *   A2 is pointing to the head of the string that needs to be appended to the string buffer. A5 is pointing to the head of the string buffer.
00002972                          2817  *
00002972                          2818  * Postconditions & Output:
00002972                          2819  *   A5 has the string pointed to by A2 appended to its string buffer. And A1 also is made to point to the head of the string buffer block.
00002972                          2820  *
00002972                          2821  *  A5 points to the string buffer
00002972                          2822  *  A2 points to the string to be appended to the buffer
00002972                          2823  *  A1 points to the head of the string buffer as a return value of the function
00002972                          2824  ********************************************************************************
00002972                          2825  AppendingRegs   REG     A2,D5
00002972                          2826  Start_String_Appending
00002972  48A7 0020               2827      MOVEM AppendingRegs,-(SP)
00002976                          2828      
00002976                          2829  String_Appending_Loop
00002976  0C12 0000               2830      CMPI.B #$00,(A2)
0000297A  6700 000A               2831      BEQ EndStringLoop
0000297E  1ADA                    2832      MOVE.B (A2)+,(A5)+
00002980                          2833      
00002980                          2834  AddNullToStringBuffer
00002980  1ABC 0000               2835      MOVE.B #$00,(A5)
00002984  60F0                    2836      BRA String_Appending_Loop
00002986                          2837      
00002986                          2838  EndStringLoop
00002986  43F9 00002A9F           2839      LEA String_Buffer_Block,A1
0000298C  4C9F 0400               2840      MOVEM (SP)+,AppendingRegs
00002990  4E75                    2841      RTS
00002992                          2842      
00002992                          2843    
00002992                          2844  *********************************************************************************
00002992                          2845  * Method Name: Clear_String_Buffer
00002992                          2846  * Description: Clears the contents of the string buffer to prepare for the next instruction to be read, or to rewrite the buffer for printing an
00002992                          2847  *   error string ("XXXXXXXX DATA YYYY").
00002992                          2848  *
00002992                          2849  * Calling Convention: Caller-Saved
00002992                          2850  *
00002992                          2851  * Preconditions & Method Input:
00002992                          2852  *   None
00002992                          2853  *
00002992                          2854  * Postconditions & Output:
00002992                          2855  *   The string buffer block is left with no elements (data) in its contents.
00002992                          2856  *
00002992                          2857  *  A1 points to the string buffer block
00002992                          2858  *  D5 stores a counter for the loop to iterate through as many blocks as there exist in the string buffer block (in this case, 20)
00002992                          2859  ********************************************************************************  
00002992                          2860  Clear_String_Buffer
00002992  48A7 0020               2861      MOVEM AppendingRegs,-(SP)
00002996  43F9 00002A9F           2862      LEA String_Buffer_Block,A1
0000299C  3A3C 0014               2863      MOVE #20,D5  
000029A0                          2864  ClearStringBufferLoop
000029A0  0C45 0000               2865      CMPI #0,D5
000029A4  6700 000C               2866      BEQ EmptiedBuffer
000029A8  12BC 00FF               2867      MOVE.B #$FF,(A1)
000029AC  5249                    2868      ADD #1,A1
000029AE  5345                    2869      SUB #1,D5
000029B0  60EE                    2870      BRA ClearStringBufferLoop
000029B2                          2871  EmptiedBuffer
000029B2  12BC 00FF               2872      MOVE.B #$FF,(A1)
000029B6  4C9F 0400               2873      MOVEM (SP)+,AppendingRegs
000029BA  4E75                    2874      RTS
000029BC                          2875  
000029BC                          2876  
000029BC                          2877  *********************************************************************************
000029BC                          2878  * Method Name: Add_Hex_String_To_Buffer
000029BC                          2879  * Description: Takes the hex value stored in D1, and converts it from hex to ascii via the label inside called "HexToAscii", then appends this value to the string
000029BC                          2880  * buffer block by using "Start_String_Appending".
000029BC                          2881  *
000029BC                          2882  * Calling Convention: Caller-Saved
000029BC                          2883  *
000029BC                          2884  * Preconditions & Method Input:
000029BC                          2885  *   The value to be converted to ascii and appended to the string buffer block is stored in D1.
000029BC                          2886  *
000029BC                          2887  * Postconditions & Output:
000029BC                          2888  *   The ascii converted value of the hex value stored in D1 is appended to the string buffer block. The value stored in D3 represents the 
000029BC                          2889  *   the width of the ascii hex value intended (4 gives a byte, 12 gives a word, 28 gives a long).
000029BC                          2890  *
000029BC                          2891  *  A2 is the register that Start_String_Appending appends to the string buffer block, so it is where the converted hex value is appended.
000029BC                          2892  *  D3 holds the width of the ascii hex value intended
000029BC                          2893  *  D6 holds value to be converted (moved from D1) and is manipulated to convert a nibble at a time and place them in memory space pointed to by A2
000029BC                          2894  ********************************************************************************  
000029BC                          2895  Add_Hex_String_To_Buffer
000029BC  347C 6000               2896      MOVE #$6000,A2
000029C0  48A7 7220               2897      MOVEM D1/D2/D3/D6/A2,-(SP)
000029C4  4EB9 000029D4           2898      JSR HexToAscii
000029CA  4C9F 044E               2899      MOVEM (SP)+,D1/D2/D3/D6/A2
000029CE  4EB8 2972               2900      JSR Start_String_Appending
000029D2  4E75                    2901      RTS
000029D4                          2902  
000029D4                          2903  HexToAscii
000029D4  0C43 0000               2904      CMPI #$0,D3
000029D8  6D00 0026               2905      BLT EndConversion
000029DC  2C01                    2906      MOVE.L D1,D6
000029DE  E6AE                    2907      LSR.L D3,D6
000029E0  0286 0000000F           2908      ANDI.L #$0000000F,D6
000029E6  1486                    2909      MOVE.B D6,(A2)
000029E8  0C12 000A               2910      CMPI.B #10,(A2)
000029EC  6D00 000A               2911      BLT AddForNumeric
000029F0                          2912  AddForLetter
000029F0  061A 0037               2913      ADDI.B #55,(A2)+
000029F4  6000 0006               2914      BRA After_Addition
000029F8                          2915  AddForNumeric
000029F8  061A 0030               2916      ADDI.B #48,(A2)+
000029FC                          2917  After_Addition
000029FC  5943                    2918      SUBI #4,D3
000029FE  60D4                    2919      BRA HexToAscii
00002A00                          2920  EndConversion
00002A00  14BC 0000               2921      MOVE.B #$00,(A2)
00002A04  4E75                    2922      RTS
00002A06                          2923     
00002A06                          2924  *********************************************************************************
00002A06                          2925  * Method Name: Error_Subroutine
00002A06                          2926  * Description: Clears the string buffer to prepare for an error and to load the string buffer with the error string "XXXXXXXX DATA YYYY",
00002A06                          2927  *              where X is the memory address of the instruction that resulted in an error in processing, and the Y is the data stored at the
00002A06                          2928  *              memory location that initiated the error. This is then printed to the console and out to the file "output.txt" via the
00002A06                          2929  *              TrapTask13 function.
00002A06                          2930  *
00002A06                          2931  * Calling Convention: None
00002A06                          2932  *
00002A06                          2933  * Preconditions & Method Input:
00002A06                          2934  *   A undetermined opcode or addressing mode was detected. A0 is pointing at the same location as A4 (and thus at the same address as the instruction
00002A06                          2935  *   that initiated the error)
00002A06                          2936  *
00002A06                          2937  * Postconditions & Output:
00002A06                          2938  *   The string buffer block is erased and replaced with the error data string from above, and printed to console and "output.txt" file.
00002A06                          2939  *
00002A06                          2940  *  A5 holds the head of the string buffer block
00002A06                          2941  *  A0 points to the current instruction opcode word and moves its value to D1 for conversion to hex to be prepared via "Add_Hex_String_To_Buffer" for
00002A06                          2942  *  proper formatting of error data string as above.
00002A06                          2943  *  D3 specifies the intended width of the ascii converted hex value (4: byte, 12: word, 28: long)
00002A06                          2944  *  A2 points to where the "DATA" string is loaded in memory, to prepare for appending to the string buffer via "Start_String_Appending"
00002A06                          2945  *  D7 holds the current instruction opcode word
00002A06                          2946  *  D1 holds the value that is hex converted to ascii via "Add_Hex_String_To_Buffer" (which has a precondition that its converting variable is placed in D1)
00002A06                          2947  *  D0 stores the amount by which A4 will be incremented after the completion of this function
00002A06                          2948  ********************************************************************************
00002A06                          2949  Error_Subroutine
00002A06  4EB8 2992               2950      JSR Clear_String_Buffer
00002A0A  4BF9 00002A9F           2951      LEA String_Buffer_Block, A5
00002A10  2208                    2952      MOVE.L A0,D1
00002A12  363C 001C               2953      MOVE #28,D3    * flags the address of the current instruction that is placed before the "DATA" word as being long (8 hex characters)
00002A16  4EB8 29BC               2954      JSR Add_Hex_String_To_Buffer
00002A1A  4EB8 290A               2955      JSR Add_Space
00002A1E  45F9 00002AF4           2956      LEA Print_Data_Error,A2
00002A24  4EB8 2972               2957      JSR Start_String_Appending
00002A28  4EB8 290A               2958      JSR Add_Space
00002A2C  2207                    2959      MOVE.L D7,D1
00002A2E  363C 000C               2960      MOVE #12,D3   * flags the data at the address of the current instruction that is placed after the "DATA" word as being word (4 hex characters)
00002A32  4EB8 29BC               2961      JSR Add_Hex_String_To_Buffer
00002A36  4EB8 2694               2962      JSR TrapTask13
00002A3A  303C 0002               2963      MOVE #2,D0
00002A3E  4E75                    2964      RTS
00002A40                          2965  
00002A40                          2966  
00002A40                          2967  *********************************************************************************
00002A40                          2968  * Method Name: StoreAddressesFromConfig
00002A40                          2969  * Description: Opens the file specified in the configFilename variable that is defined in the Variables section. Once the file has been opened, 
00002A40                          2970  *              the method will load an uninitialized area of code 64 bits long, to account for the ASCII representation of a long. It will grab 
00002A40                          2971  *              the next 8 ASCII chars, and then covert those chars into Hex and place it in the region of memory corresponding to the variable 
00002A40                          2972  *              Start_Address. It skips over the next two ASCII chars, and then repeat the process for the 8 ASCII chars that represent the 
00002A40                          2973  *              End_Address variable. After this it closes the file
00002A40                          2974  * 
00002A40                          2975  * Calling Convention: Caller-Save
00002A40                          2976  *
00002A40                          2977  * Preconditions & Method Input:
00002A40                          2978  *   configFilename is initialized to a file name
00002A40                          2979  *   File format of the configFilename file is
00002A40                          2980  *    <Long_StartAddress>\CR\LF
00002A40                          2981  *    <Long_EndAddress>\CR\LF<EOF>
00002A40                          2982  *
00002A40                          2983  * Postconditions & Output:
00002A40                          2984  *   Start_Address and End_Address contain the memory address defined in the configFileName file.
00002A40                          2985  *
00002A40                          2986  *  D0 holds the trap task that will be used for File IO
00002A40                          2987  *  A1 hold the file name for the file that you want to open, as well as holds head of the string buffer for the ASCII to Hex coversion
00002A40                          2988  *  D2 hold the number of bytes that the Trap Task will read from the file
00002A40                          2989  ********************************************************************************
00002A40                          2990  ConfigRegList   REG D0/D2/A1
00002A40                          2991  
00002A40                          2992  StoreAddressesFromConfig
00002A40  48E7 A040               2993      MOVEM.L ConfigRegList, -(SP)
00002A44  303C 0032               2994      MOVE #50, D0
00002A48  4E4F                    2995      TRAP #15
00002A4A                          2996  
00002A4A  303C 0033               2997      MOVE #51, D0
00002A4E  43F9 00002AE0           2998      LEA configFilename, A1
00002A54  4E4F                    2999      TRAP #15
00002A56                          3000  
00002A56  43F9 00002AB4           3001      LEA AddrBuffer, A1
00002A5C  7408                    3002      MOVE.L #8, D2
00002A5E  303C 0035               3003      MOVE #53, D0
00002A62  4E4F                    3004      TRAP #15
00002A64                          3005  
00002A64                          3006  
00002A64  4EB8 272A               3007      JSR AsciiToHex
00002A68  23C7 00002AEC           3008      MOVE.L D7, Start_Address
00002A6E                          3009  
00002A6E  4287                    3010      CLR.L D7
00002A70                          3011  
00002A70  7402                    3012      MOVE.L #2, D2
00002A72  303C 0035               3013      MOVE #53, D0
00002A76  4E4F                    3014      TRAP #15
00002A78                          3015  
00002A78                          3016  
00002A78  43F9 00002AB4           3017      LEA AddrBuffer, A1
00002A7E  7408                    3018      MOVE.L #8, D2
00002A80  303C 0035               3019      MOVE #53, D0
00002A84  4E4F                    3020      TRAP #15
00002A86                          3021  
00002A86  4EB8 272A               3022      JSR AsciiToHex
00002A8A  23C7 00002AF0           3023      MOVE.L D7, End_Address
00002A90                          3024      
00002A90  103C 0038               3025      MOVE.B #56, D0
00002A94  4E4F                    3026      TRAP #15
00002A96                          3027  
00002A96  4CDF 0205               3028      MOVEM.L (SP)+,ConfigRegList
00002A9A  4E75                    3029      RTS
00002A9C                          3030         
00002A9C                          3031  * Required variables and constants go here for your Disassembler
00002A9C  =0000000D               3032  CR                  EQU $0D
00002A9C  =0000000A               3033  LF                  EQU $0A
00002A9C= 0D 0A 00                3034  NEWLINE             DC.B CR,LF,0
00002A9F                          3035  String_Buffer_Block DS.B 20
00002AB4                          3036  AddrBuffer          DS.L 2
00002ABC= 4D 4F 56 45 2E 4C ...   3037  MSG1                DC.B 'MOVE.L D4,D5',0
00002AC9= 41 44 44 2E 42 20 ...   3038  MSG2                DC.B 'ADD.B D0,D1',0
00002AD5= 4F 75 74 70 75 74 ...   3039  outFilename         DC.B 'Output.txt',0
00002AE0= 63 6F 6E 66 69 67 ...   3040  configFilename      DC.B 'config.cfg',0
00002AEB                          3041  byteRead            DS.B 1
00002AEC                          3042  Start_Address       DS.L  1
00002AF0                          3043  End_Address         DS.L  1
00002AF4  =00000E00               3044  Move_Destination_Register EQU $0E00
00002AF4  =000001C0               3045  Move_Destination_Mode     EQU $01C0
00002AF4  =00000038               3046  Move_Source_Mode    EQU $0038
00002AF4  =00000007               3047  Move_Source_Register      EQU $0007
00002AF4  =0000FF80               3048  MoveM_Op_Code_Mask  EQU $FF80
00002AF4  =0000F1C0               3049  Bit_Test_and_Clear_Mask EQU $F1C0
00002AF4  =0000FFC0               3050  Bit_Test_and_Clear_Mask2 EQU $FFC0
00002AF4  =0000FFC0               3051  JSR_Mask            EQU $FFC0
00002AF4  =0000F1C0               3052  LEA_MULS_Mask       EQU $F1C0
00002AF4  =0000FF00               3053  NEG_BRA_Mask        EQU $FF00
00002AF4  =0000F000               3054  Bcc_CMPI_Mask       EQU $F000
00002AF4  =0000F100               3055  SubQ_Mask           EQU $F100
00002AF4  =0000FFFF               3056  Isolate_Second_Word EQU $0000FFFF
00002AF4= 44 41 54 41 00          3057  Print_Data_Error    DC.B 'DATA',0
00002AF9= 4D 4F 56 45 00          3058  Move_op             DC.B 'MOVE',0
00002AFE= 4D 4F 56 45 41 00       3059  MoveA_op            DC.B 'MOVEA',0
00002B04= 4D 4F 56 45 4D 00       3060  MoveM_op            DC.B 'MOVEM',0
00002B0A= 4E 4F 50 00             3061  NOP_op              DC.B 'NOP',0
00002B0E= 52 54 53 00             3062  RTS_op              DC.B 'RTS',0
00002B12= 42 43 4C 52 00          3063  BCLR_op             DC.B 'BCLR',0
00002B17= 4A 53 52 20 00          3064  JSR_op              DC.B 'JSR ',0
00002B1C= 4C 45 41 2E 4C 20 00    3065  LEA_op              DC.B 'LEA.L ',0
00002B23= 4E 45 47 00             3066  NEG_op              DC.B 'NEG',0
00002B27= 42 52 41 00             3067  BRA_op              DC.B 'BRA',0
00002B2B= 42 43 53 00             3068  BCS_op              DC.B 'BCS',0
00002B2F= 42 47 45 00             3069  BGE_op              DC.B 'BGE',0
00002B33= 42 4C 54 00             3070  BLT_op              DC.B 'BLT',0
00002B37= 42 56 43 00             3071  BVC_op              DC.B 'BVC',0
00002B3B= 43 4D 50 00             3072  CMP_op              DC.B 'CMP',0
00002B3F= 43 4D 50 49 00          3073  CMPI_op             DC.B 'CMPI',0
00002B44= 4C 53 4C 00             3074  LSL_op              DC.B 'LSL',0
00002B48= 4C 53 52 00             3075  LSR_op              DC.B 'LSR',0
00002B4C= 41 53 4C 00             3076  ASL_op              DC.B 'ASL',0
00002B50= 41 53 52 00             3077  ASR_op              DC.B 'ASR',0
00002B54= 52 4F 4C 00             3078  ROL_op              DC.B 'ROL',0
00002B58= 52 4F 52 00             3079  ROR_op              DC.B 'ROR',0
00002B5C= 45 4F 52 00             3080  EOR_op              DC.B 'EOR',0
00002B60= 4F 52 00                3081  OR_op               DC.B 'OR',0
00002B63= 4F 52 49 00             3082  ORI_op              DC.B 'ORI',0
00002B67= 41 44 44 00             3083  Add_op              DC.B 'ADD',0
00002B6B= 41 44 44 41 00          3084  ADDA_op             DC.B 'ADDA',0
00002B70= 53 55 42 00             3085  SUB_op              DC.B 'SUB',0
00002B74= 53 55 42 51 00          3086  SUBQ_op             DC.B 'SUBQ',0
00002B79= 4D 55 4C 53 00          3087  MULS_op             DC.B 'MULS',0
00002B7E= 44 49 56 53 00          3088  DIVS_op             DC.B 'DIVS',0
00002B83= 44 00                   3089  Data_Register       DC.B 'D',0
00002B85= 41 00                   3090  Address_Register    DC.B 'A',0
00002B87= 2E 57 20 00             3091  Word_Size           DC.B '.W ',0
00002B8B= 2E 42 20 00             3092  Byte_Size           DC.B '.B ',0
00002B8F= 2E 4C 20 00             3093  Long_Size           DC.B '.L ',0
00002B93= 28 00                   3094  Open_Paren          DC.B '(',0
00002B95= 29 00                   3095  Close_Paren         DC.B ')',0
00002B97= 2B 00                   3096  Plus                DC.B '+',0
00002B99= 2D 00                   3097  Minus               DC.B '-',0
00002B9B= 24 00                   3098  HexCash             DC.B '$',0
00002B9D= 23 00                   3099  Pound               DC.B '#',0
00002B9F= 2C 00                   3100  Comma               DC.B ',',0
00002BA1= 2F 00                   3101  Slash               DC.B '/',0
00002BA3= 20 00                   3102  Empty_Space         DC.B ' ',0
00002BA5                          3103  
00002BA5                          3104     END    START        ; last line of source

No errors detected
2 warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_ADDRESSING  253A
ABSOLUTE_ADDRESS_WORD  257C
ADDA_DISASSEMBLY    1312
ADDA_OP             2B6B
ADDFORLETTER        29F0
ADDFORNUMERIC       29F8
ADDHEXCASH          27AA
ADDINGFORMOVEM      27FA
ADDINGFORNONMOVEM   27F2
ADDNEWLINE          27C6
ADDNULLTOSTRINGBUFFER  2980
ADDPOSTINCREMENT    278E
ADDPOUNDSIGN        27B8
ADDPREDECREMENT     279C
ADDRBUFFER          2AB4
ADDRESSING_REGS     2
ADDRESS_REG         230C
ADDRESS_REGISTER    2B85
ADDRESS_REG_DIRECT  23D2
ADDRESS_REG_INDIRECT  2458
ADDRESS_REG_INDIR_POST_INC  2490
ADDRESS_REG_INDIR_PRE_DEC  24E6
ADD_COMMA           28FC
ADD_DISASSEMBLY     1372
ADD_ERROR           1422
ADD_HEX_STRING_TO_BUFFER  29BC
ADD_OP              2B67
ADD_SLASH           2918
ADD_SPACE           290A
AFTEREIGHT          17B2
AFTERMOVEMDECISION  27FE
AFTERNEGMOVEDECISION  25A0
AFTER_ABSOLUTE      2558
AFTER_ADDITION      29FC
AFTER_ADDITION_DECISION  12B6
AFTER_AREG_IN       2476
AFTER_AREG_INPOST   24AE
AFTER_AREG_INPRE    2504
AFTER_BCLR_DECISION  2432
AFTER_DECISION      22BC
AFTER_DECISION_ADD  137E
AFTER_FLAG_DECISION  1E04
AFTER_LEA_DECISION  2596
AFTER_MULTS_DECISION  11E8
AFTER_OP_DECIDED    2610
AFTER_OR_DECISION   1580
AFTER_POTENTIAL_D0_INCREMENT  2820
AFTER_SIZE_DECISION  1CDA
AFTER_SIZE_EOR      1A00
AFTER_SIZE_OR       1534
AFTER_SIZE_ORI      1494
AFTER_SIZE_SUBQ     128C
AFTER_WORD_DECISION  1B50
APPENDINGREGS       400
ASCIITOHEX          272A
ASCIITOHEXREGLIST   1
ASL_OP              2B4C
ASR_OP              2B50
BCC_CMPI_MASK       F000
BCLR_A              2450
BCLR_ABSOLUTE       2542
BCLR_AREGIN         2460
BCLR_AREGINPOST     2498
BCLR_AREGINPRE      24EE
BCLR_DATA_REGISTER_PRINT  1D0E
BCLR_ERROR          1CBE
BCLR_OP             2B12
BCLR_PROC           25B6
BCLR_REGS           F
BCS                 1A7A
BCS_OP              2B2B
BGE                 1A8A
BGE_OP              2B2F
BIT_TEST_AND_CLEAR_MASK  F1C0
BIT_TEST_AND_CLEAR_MASK2  FFC0
BLT                 1A9A
BLT_OP              2B33
BRA                 1ABA
BRA_OP              2B27
BVC                 1AAA
BVC_OP              2B37
BYTEREAD            2AEB
BYTE_OPERATION      2250
BYTE_ORI            1462
BYTE_PRINT          2948
BYTE_SIZE           2B8B
BYTE_SIZE_ADD       13A6
BYTE_SIZE_EOR       19E6
BYTE_SIZE_OR        150E
BYTE_SIZE_SUBQ      1262
CALCULATEREGISTERNUM  22D4
CALLAPRINTNUMBER    21C8
CALLDPRINTNUMBER    21AE
CHANGETOEIGHT       12B4
CHECKCONDITION      1A4E
CHECK_ORDER_ADD     13CC
CHRDONE             2746
CHRLOOP             2732
CLEARSTRINGBUFFERLOOP  29A0
CLEAR_STRING_BUFFER  2992
CLOSEPAREN          2780
CLOSE_PAREN         2B95
CMPI_BYTE           1840
CMPI_ERROR          18F4
CMPI_LONG           18A0
CMPI_OP             2B3F
CMPI_WORD           1872
CMP_BYTE            1942
CMP_ERROR           19A6
CMP_LONG            1962
CMP_OP              2B3B
CMP_WORD            1952
COMMA               2B9F
CONFIGFILENAME      2AE0
CONFIGREGLIST       205
CONTINUEMEMORYSHIFT  167C
CONTINUE_ADDA       1352
CONVERTFROMEIGHT    17AE
COUNTDONE           26E6
COUNTLOOP           26D4
CR                  D
DATA_ADD_FIRST      13DA
DATA_REG            2302
DATA_REGISTER       2B83
DATA_REG_DIRECT     25AE
DECIDED_OPERAND     239E
DECISION_REGISTER   22F4
DESTADDRESSINGMODEDETERMINE  2374
DESTINATION_CALCULATION  22E6
DESTINATION_OPERAND  2382
DISPLAYINHEX        27D4
DIVS_OP             2B7E
EFFECTIVEADD_ADD_FIRST  13F8
EMPTIEDBUFFER       29B2
EMPTY_SPACE         2BA3
END                 2312
ENDCONVERSION       2A00
ENDSHIFT            17F4
ENDSTRINGLOOP       2986
END_ADD             1416
END_ADDRESS         2AF0
END_BCLR            1D0A
END_EFF_ADD         268E
END_PROGRAM         233C
EOR_ERROR           1A30
EOR_OP              2B5C
ERROR_MODE          267C
ERROR_SUBROUTINE    2A06
FINDNULLLOOPDONE    26B6
FIN_ISOL            284E
FIN_ISOL2           28B0
FORCE_LEA_LONG      2592
GETDESTINATIONREG   22B0
GETREGISTERLIST     1DEC
GETSOURCEREG        22A6
HEXCASH             2B9B
HEXTOASCII          29D4
IMMEDIATE_ADDRESSING  2618
INCREMENT_FUNCTION  28D6
ISOLATEBYTE         287A
ISOLATEINSTROPERANDS  2856
ISOLATELONG         289A
ISOLATESECONDINSTRWORD  27DC
ISOLATEWORD         288E
ISOLATE_SECOND_WORD  FFFF
JSR_MASK            FFC0
JSR_OP              2B17
JUST_A_WORD         2832
LEA_MULS_MASK       F1C0
LEA_OP              2B1C
LF                  A
LONG_ADDA           133E
LONG_OPERATION      2280
LONG_ORI            1486
LONG_PRINT          2964
LONG_SIZE           2B8F
LONG_SIZE_ADD       13C2
LONG_SIZE_EOR       19FA
LONG_SIZE_OR        152A
LONG_SIZE_SUBQ      1282
LSD_REGISTER_MASK_ISOLATE  2934
LSL_OP              2B44
LSR_OP              2B48
MARK1               1E20
MARK10              2024
MARK11              2060
MARK12              209C
MARK13              20D8
MARK14              2114
MARK15              2150
MARK16              218C
MARK2               1E58
MARK3               1E90
MARK4               1EC8
MARK5               1F00
MARK6               1F38
MARK7               1F70
MARK8               1FA8
MARK9               1FE0
MEMORY_ARITHMETIC_SHIFT_LEFT  1612
MEMORY_ARITHMETIC_SHIFT_RIGHT  15FC
MEMORY_LOGICAL_SHIFT_LEFT  166A
MEMORY_LOGICAL_SHIFT_RIGHT  1654
MEMORY_ROLL_LEFT    1628
MEMORY_ROLL_RIGHT   163E
MEM_TO_REG          1D98
MINUS               2B99
MOVEA_OP            2AFE
MOVEM_CHECK         2432
MOVEM_OP            2B04
MOVEM_OP_CODE_MASK  FF80
MOVEM_PREDECREMENT  28DA
MOVEM_PREDECREMENT_REV  28EE
MOVEM_PROC          25D0
MOVEM_SUBTRACT      284C
MOVESIZEIDENTIFIER  259E
MOVE_ADDRESS        221A
MOVE_DESTINATION_MODE  1C0
MOVE_DESTINATION_REGISTER  E00
MOVE_OP             2AF9
MOVE_OPERATION      21F4
MOVE_REGISTERS      8
MOVE_SOURCE_MODE    38
MOVE_SOURCE_REGISTER  7
MSG1                2ABC
MSG2                2AC9
MULS_OP             2B79
M_SIZE_DECIDED      1D64
NEG_BRA_MASK        FF00
NEG_BYTE            1B9C
NEG_ERROR           1BE0
NEG_LONG            1BB8
NEG_OP              2B23
NEG_SIZE_DETERMINED  1BC2
NEG_WORD            1BAA
NEWLINE             2A9C
NEXTPOINT1          1E3E
NEXTPOINT10         2044
NEXTPOINT11         2080
NEXTPOINT12         20BC
NEXTPOINT13         20F8
NEXTPOINT14         2134
NEXTPOINT15         2170
NEXTPOINT16         21AC
NEXTPOINT2          1E76
NEXTPOINT3          1EAE
NEXTPOINT4          1EE6
NEXTPOINT5          1F1E
NEXTPOINT6          1F56
NEXTPOINT7          1F8E
NEXTPOINT8          1FC6
NEXTPOINT9          2004
NOP_OP              2B0A
NOP_OPERATION       2344
NOTMET1             1E1C
NOTMET10            2020
NOTMET11            205C
NOTMET12            2098
NOTMET13            20D4
NOTMET14            2110
NOTMET15            214C
NOTMET16            2188
NOTMET2             1E54
NOTMET3             1E8C
NOTMET4             1EC4
NOTMET5             1EFC
NOTMET6             1F34
NOTMET7             1F6C
NOTMET8             1FA4
NOTMET9             1FDC
NULLLOOP            26A8
ONE_BYTE            1AE4
ONE_WORD            1B18
OPENPAREN           2772
OPEN_PAREN          2B93
ORI_ERROR           14CE
ORI_OP              2B63
OR_ERROR            158C
OR_OP               2B60
OUTFILENAME         2AD5
PLACE_D7_IN_D3      28D2
PLUS                2B97
POUND               2B9D
PREDECREMENTMODE    1E38
PREDECREMENTMODE10  203E
PREDECREMENTMODE11  207A
PREDECREMENTMODE12  20B6
PREDECREMENTMODE13  20F2
PREDECREMENTMODE14  212E
PREDECREMENTMODE15  216A
PREDECREMENTMODE16  21A6
PREDECREMENTMODE2   1E70
PREDECREMENTMODE3   1EA8
PREDECREMENTMODE4   1EE0
PREDECREMENTMODE5   1F18
PREDECREMENTMODE6   1F50
PREDECREMENTMODE7   1F88
PREDECREMENTMODE8   1FC0
PREDECREMENTMODE9   1FFA
PRINT_ADDRESS_REGISTER  28C4
PRINT_ARITHMETICL   170A
PRINT_ARITHMETICR   16DA
PRINT_DATA_ERROR    2AF4
PRINT_DATA_REGISTER  28B6
PRINT_DATA_REG_FIRST  1540
PRINT_EFFECTIVE_ADDRESS_FIRST  1562
PRINT_ERROR         2926
PRINT_LONG          1D54
PRINT_RORL          171A
PRINT_RORR          16CA
PRINT_WORD          1D5E
PROCESSREGISTER     1774
PROCESSREGISTERSHIFT  1726
PROCESS_BCC_DISASSEMBLY  1AC6
PROCESS_CMP         196E
PROCESS_CMPI        18D4
REGISTERIMMEDIATE   178E
REGISTERSPECIFIED   17CE
REGISTER_LEFT       16EA
REGISTER_RIGHT      16AA
REGISTER_SHIFT      1694
REG_BYTE            174E
REG_LONG            176A
REG_TO_MEM          1DC2
REG_WORD            175C
RET_SA              2770
ROL_OP              2B54
ROR_OP              2B58
RTS_OP              2B0E
RTS_OPERATION       235C
R_DESTINATION       2298
SET_D3_FOR_LONG_OPERAND_FLAG  2578
SET_FLAG            1E00
SHIFT_ERROR         1800
SIZE_CONFIRMED      2316
SLASH               2BA1
SOURCE_CALCULATION  22DE
SOURCE_OPERAND      2392
STANDARD_MOVE       220A
START               1000
START_ADDRESS       2AEC
START_ADD_DISASSEMBLY  12FE
START_BCC_DISASSEMBLY  1A3C
START_CMPI_DISASSEMBLY  180C
START_CMP_DISASSEMBLY  1900
START_DISASSEMBLY   101C
START_DIVS_DISASSEMBLY  11DC
START_EOR_DISASSEMBLY  19B2
START_JSR_DISASSEMBLY  1C2A
START_LEA_DISASSEMBLY  1BEC
START_MOVEM_TOM_DISASSEMBLY  1D38
START_MOVE_DISASSEMBLY  21E2
START_MULS_DIVS_DISASSEMBLY  11CC
START_MULTS_DISASSEMBLY  11CC
START_NEG_DISASSEMBLY  1B68
START_ORI_DISASSEMBLY  142E
START_OR_DISASSEMBLY  14DA
START_SHIFTING_DISASSEMBLY  1598
START_STRING_APPENDING  2972
START_SUBQ_DISASSEMBLY  122E
START_SUB_DISASSEMBLY  12EC
START_TEST_BIT_CLEAR_DISASSEMBLY1  1C52
START_TEST_BIT_CLEAR_DISASSEMBLY2  1C7A
STOREADDRESSESFROMCONFIG  2A40
STRING_APPENDING_LOOP  2976
STRING_BUFFER_BLOCK  2A9F
STRIP_ASCII         274C
SUB30               276C
SUB37               2764
SUBQ_ERROR          12E0
SUBQ_MASK           F100
SUBQ_OP             2B74
SUBTYPE_DECIDED     2226
SUB_OP              2B70
TOSAVE              C3F
TRAPTASK13          2694
UNRECOGNIZEDCONDITION  1B5C
WORD_ADDA           1326
WORD_OPERATION      2268
WORD_ORI            1474
WORD_PRINT          2956
WORD_SIZE           2B87
WORD_SIZE_ADD       13B4
WORD_SIZE_EOR       19F0
WORD_SIZE_OR        151C
WORD_SIZE_SUBQ      1274
WRITEBYTE           1CAA
WRITELONG           1CCA
_00000000           26CA
